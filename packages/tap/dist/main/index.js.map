{"version":3,"file":"main/index.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAa,IAAID,IAEjBD,EAAU,IAAIC,GACf,CATD,CASGK,MAAM,I,qCCPmUJ,EAAQ,GAA+IA,EAAQ,GAASA,EAAQ,QAAgB,EAC5gB,MAAMK,EAAgBC,GAAS,kBAAkBA,IAMjDN,EAAQ,GALc,CAACO,EAAWC,KAC9B,IAAKD,EACD,MAAM,IAAIE,UAAUD,EACxB,EAGJ,IAAIE,EAAaV,EAAQ,GAEzBA,EAAQ,GADO,CAACO,EAAWC,IAAYE,EAAWH,EAAWC,GA6B7DR,EAAQ,GAHR,SAAmBW,EAAOH,EAAUH,EAAa,gCAC7C,EAAIL,EAAQ,IAAQW,QAAuCH,EAC/D,C,GCtCII,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAaf,QAGrB,IAAIC,EAASW,EAAyBE,GAAY,CAGjDd,QAAS,CAAC,GAOX,OAHAiB,EAAoBH,GAAUb,EAAQA,EAAOD,QAASa,GAG/CZ,EAAOD,OACf,CCrBAa,EAAoBK,EAAI,CAAClB,EAASmB,KACjC,IAAI,IAAIC,KAAOD,EACXN,EAAoBQ,EAAEF,EAAYC,KAASP,EAAoBQ,EAAErB,EAASoB,IAC5EE,OAAOC,eAAevB,EAASoB,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDP,EAAoBQ,EAAI,CAACK,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCClFd,EAAoBkB,EAAK/B,IACH,oBAAXgC,QAA0BA,OAAOC,aAC1CX,OAAOC,eAAevB,EAASgC,OAAOC,YAAa,CAAEC,MAAO,WAE7DZ,OAAOC,eAAevB,EAAS,aAAc,CAAEkC,OAAO,GAAO,E,kECJ9D,SAAgBC,EAAG3B,KACf,KAAY2B,EAAG3B,GACR2B,E","sources":["webpack://tap/webpack/universalModuleDefinition","webpack://tap/../../node_modules/.pnpm/typed-assert@1.0.9/node_modules/typed-assert/build/index.js","webpack://tap/webpack/bootstrap","webpack://tap/webpack/runtime/define property getters","webpack://tap/webpack/runtime/hasOwnProperty shorthand","webpack://tap/webpack/runtime/make namespace object","webpack://tap/./src/tapNonNull/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"tap\"] = factory();\n\telse\n\t\troot[\"tap\"] = factory();\n})(self, () => {\nreturn ","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.check = exports.isPromise = exports.isInstanceOf = exports.isOneOfType = exports.isOneOf = exports.isOptionOfType = exports.isArrayOfType = exports.isRecordOfType = exports.isArray = exports.isRecordWithKeys = exports.isRecord = exports.isDate = exports.isString = exports.isNumber = exports.isBoolean = exports.isExactly = exports.isNotVoid = exports.isNotUndefined = exports.isNotNull = exports.isNever = exports.isUnknown = exports.safeJsonParse = exports.setBaseAssert = exports.assert = exports.defaultAssert = void 0;\nconst expectedToBe = (type) => `expected to be ${type}`;\nconst defaultAssert = (condition, message) => {\n    if (!condition) {\n        throw new TypeError(message);\n    }\n};\nexports.defaultAssert = defaultAssert;\nlet baseAssert = exports.defaultAssert;\nconst assert = (condition, message) => baseAssert(condition, message);\nexports.assert = assert;\nfunction setBaseAssert(assert) {\n    if (assert) {\n        baseAssert = assert;\n    }\n}\nexports.setBaseAssert = setBaseAssert;\nconst safeJsonParse = (json) => JSON.parse(json);\nexports.safeJsonParse = safeJsonParse;\nfunction isUnknown(_input) {\n    return true;\n}\nexports.isUnknown = isUnknown;\nfunction isNever(_input, message = expectedToBe(\"unreachable\")) {\n    throw new TypeError(message);\n}\nexports.isNever = isNever;\nfunction isNotNull(input, message = expectedToBe(\"not null\")) {\n    (0, exports.assert)(input !== null, message);\n}\nexports.isNotNull = isNotNull;\nfunction isNotUndefined(input, message = expectedToBe(\"not undefined\")) {\n    (0, exports.assert)(input !== undefined, message);\n}\nexports.isNotUndefined = isNotUndefined;\nfunction isNotVoid(input, message = expectedToBe(\"neither null nor undefined\")) {\n    (0, exports.assert)(input !== null && input !== undefined, message);\n}\nexports.isNotVoid = isNotVoid;\nfunction isExactly(input, value, message = expectedToBe(`exactly ${value}`)) {\n    (0, exports.assert)(input === value, message);\n}\nexports.isExactly = isExactly;\nfunction isBoolean(input, message = expectedToBe(\"a boolean\")) {\n    (0, exports.assert)(typeof input === \"boolean\", message);\n}\nexports.isBoolean = isBoolean;\nfunction isNumber(input, message = expectedToBe(\"a number\")) {\n    (0, exports.assert)(typeof input === \"number\", message);\n}\nexports.isNumber = isNumber;\nfunction isString(input, message = expectedToBe(\"a string\")) {\n    (0, exports.assert)(typeof input === \"string\", message);\n}\nexports.isString = isString;\nfunction isDate(input, message = expectedToBe(\"a Date\")) {\n    (0, exports.assert)(input instanceof Date, message);\n}\nexports.isDate = isDate;\nfunction isRecord(input, message = expectedToBe(\"a record\")) {\n    (0, exports.assert)(typeof input === \"object\", message);\n    isNotNull(input, message);\n    for (const key of Object.keys(input)) {\n        isString(key, message);\n    }\n}\nexports.isRecord = isRecord;\nfunction isRecordWithKeys(input, keys, message = expectedToBe(`a record with keys ${keys.join(\", \")}`)) {\n    isRecord(input, message);\n    for (const key of keys) {\n        isNotUndefined(input[key]);\n    }\n}\nexports.isRecordWithKeys = isRecordWithKeys;\nfunction isArray(input, message = expectedToBe(\"an array\")) {\n    (0, exports.assert)(Array.isArray(input), message);\n}\nexports.isArray = isArray;\nfunction isRecordOfType(input, assertT, message = expectedToBe(\"a record of given type\"), itemMessage = expectedToBe(\"of given type\")) {\n    isRecord(input, message);\n    for (const item of Object.values(input)) {\n        assertT(item, itemMessage);\n    }\n}\nexports.isRecordOfType = isRecordOfType;\nfunction isArrayOfType(input, assertT, message = expectedToBe(\"an array of given type\"), itemMessage = expectedToBe(\"of given type\")) {\n    isArray(input, message);\n    for (const item of input) {\n        assertT(item, itemMessage);\n    }\n}\nexports.isArrayOfType = isArrayOfType;\nfunction isOptionOfType(input, assertT, message = expectedToBe(\"option of given type\")) {\n    if (input === undefined) {\n        return;\n    }\n    assertT(input, message);\n}\nexports.isOptionOfType = isOptionOfType;\nfunction isOneOf(input, values, message = expectedToBe(`one of ${values.join(\", \")}`)) {\n    (0, exports.assert)(values.includes(input), message);\n}\nexports.isOneOf = isOneOf;\nfunction isOneOfType(input, assertT, message = expectedToBe(`one of type`), itemMessage) {\n    for (const assert of assertT) {\n        try {\n            assert(input, itemMessage);\n            return;\n        }\n        catch (_) { }\n    }\n    throw new TypeError(message);\n}\nexports.isOneOfType = isOneOfType;\nfunction isInstanceOf(input, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconstructor, message = expectedToBe(\"an instance of given constructor\")) {\n    (0, exports.assert)(input instanceof constructor, message);\n}\nexports.isInstanceOf = isInstanceOf;\nfunction isPromise(input, message = expectedToBe(\"a promise\")) {\n    isInstanceOf(input, Promise, message);\n}\nexports.isPromise = isPromise;\nfunction check(assertT) {\n    return (input) => {\n        try {\n            assertT(input);\n            return true;\n        }\n        catch (_) {\n            return false;\n        }\n    };\n}\nexports.check = check;\n//# sourceMappingURL=index.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import * as t from 'typed-assert';\nexport default (x, message) => {\n    t.isNotVoid(x, message);\n    return x;\n};\n"],"names":["root","factory","exports","module","define","amd","self","expectedToBe","type","condition","message","TypeError","baseAssert","input","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","x"],"sourceRoot":""}