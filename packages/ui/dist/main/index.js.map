{"version":3,"file":"main/index.js","mappings":"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","sources":["webpack://ui/webpack/universalModuleDefinition","webpack://ui/webpack/bootstrap","webpack://ui/webpack/runtime/define property getters","webpack://ui/webpack/runtime/hasOwnProperty shorthand","webpack://ui/webpack/runtime/make namespace object","webpack://ui/../../node_modules/.pnpm/hyperapp@2.0.22/node_modules/hyperapp/index.js","webpack://ui/./src/checkboxRow/index.ts","webpack://ui/./src/colorPicker/index.ts","webpack://ui/./src/colorTextOutput/index.ts","webpack://ui/../../node_modules/.pnpm/@effect+data@0.11.5/node_modules/@effect/data/mjs/Function.mjs","webpack://ui/../../node_modules/.pnpm/@effect+data@0.11.5/node_modules/@effect/data/mjs/Global.mjs","webpack://ui/../../node_modules/.pnpm/@effect+data@0.11.5/node_modules/@effect/data/mjs/Random.mjs","webpack://ui/../../node_modules/.pnpm/@effect+data@0.11.5/node_modules/@effect/data/mjs/Hash.mjs","webpack://ui/../../node_modules/.pnpm/@effect+data@0.11.5/node_modules/@effect/data/mjs/Equal.mjs","webpack://ui/../../node_modules/.pnpm/@effect+data@0.11.5/node_modules/@effect/data/mjs/Debug.mjs","webpack://ui/../../node_modules/.pnpm/@effect+data@0.11.5/node_modules/@effect/data/mjs/internal/Option.mjs","webpack://ui/../../node_modules/.pnpm/@effect+data@0.11.5/node_modules/@effect/data/mjs/internal/Either.mjs","webpack://ui/../../node_modules/.pnpm/@effect+data@0.11.5/node_modules/@effect/data/mjs/typeclass/Order.mjs","webpack://ui/../../node_modules/.pnpm/@effect+data@0.11.5/node_modules/@effect/data/mjs/typeclass/Bounded.mjs","webpack://ui/../../node_modules/.pnpm/@effect+data@0.11.5/node_modules/@effect/data/mjs/typeclass/Semigroup.mjs","webpack://ui/../../node_modules/.pnpm/@effect+data@0.11.5/node_modules/@effect/data/mjs/internal/Iterable.mjs","webpack://ui/../../node_modules/.pnpm/@effect+data@0.11.5/node_modules/@effect/data/mjs/typeclass/Monoid.mjs","webpack://ui/../../node_modules/.pnpm/@effect+data@0.11.5/node_modules/@effect/data/mjs/Number.mjs","webpack://ui/../../node_modules/.pnpm/@effect+data@0.11.5/node_modules/@effect/data/mjs/Option.mjs","webpack://ui/../../node_modules/.pnpm/@effect+data@0.11.5/node_modules/@effect/data/mjs/Tuple.mjs","webpack://ui/../../node_modules/.pnpm/@effect+data@0.11.5/node_modules/@effect/data/mjs/typeclass/Bicovariant.mjs","webpack://ui/./src/Editable/index.ts","webpack://ui/./src/errorText/index.ts","webpack://ui/../../node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/index.mjs","webpack://ui/./src/getChecked/index.ts","webpack://ui/./src/getValue/index.ts","webpack://ui/./src/option/index.ts","webpack://ui/./src/panelBoxStyle/index.ts","webpack://ui/./src/rangeRow/index.ts","webpack://ui/./src/settingRow/index.ts","webpack://ui/../../node_modules/.pnpm/@effect+data@0.11.5/node_modules/@effect/data/mjs/String.mjs","webpack://ui/../../node_modules/.pnpm/@effect+data@0.11.5/node_modules/@effect/data/mjs/ReadonlyArray.mjs","webpack://ui/../../node_modules/.pnpm/@effect+data@0.11.5/node_modules/@effect/data/mjs/internal/ReadonlyArray.mjs","webpack://ui/./src/tabContainer/index.ts","webpack://ui/./src/textAreaRow/index.ts","webpack://ui/./src/textInput/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ui\"] = factory();\n\telse\n\t\troot[\"ui\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var SSR_NODE = 1\nvar TEXT_NODE = 3\nvar EMPTY_OBJ = {}\nvar EMPTY_ARR = []\nvar SVG_NS = \"http://www.w3.org/2000/svg\"\n\nvar id = (a) => a\nvar map = EMPTY_ARR.map\nvar isArray = Array.isArray\nvar enqueue =\n  typeof requestAnimationFrame !== \"undefined\"\n    ? requestAnimationFrame\n    : setTimeout\n\nvar createClass = (obj) => {\n  var out = \"\"\n\n  if (typeof obj === \"string\") return obj\n\n  if (isArray(obj)) {\n    for (var k = 0, tmp; k < obj.length; k++) {\n      if ((tmp = createClass(obj[k]))) {\n        out += (out && \" \") + tmp\n      }\n    }\n  } else {\n    for (var k in obj) {\n      if (obj[k]) out += (out && \" \") + k\n    }\n  }\n\n  return out\n}\n\nvar shouldRestart = (a, b) => {\n  for (var k in { ...a, ...b }) {\n    if (typeof (isArray(a[k]) ? a[k][0] : a[k]) === \"function\") {\n      b[k] = a[k]\n    } else if (a[k] !== b[k]) return true\n  }\n}\n\nvar patchSubs = (oldSubs, newSubs = EMPTY_ARR, dispatch) => {\n  for (\n    var subs = [], i = 0, oldSub, newSub;\n    i < oldSubs.length || i < newSubs.length;\n    i++\n  ) {\n    oldSub = oldSubs[i]\n    newSub = newSubs[i]\n\n    subs.push(\n      newSub && newSub !== true\n        ? !oldSub ||\n          newSub[0] !== oldSub[0] ||\n          shouldRestart(newSub[1], oldSub[1])\n          ? [\n              newSub[0],\n              newSub[1],\n              (oldSub && oldSub[2](), newSub[0](dispatch, newSub[1])),\n            ]\n          : oldSub\n        : oldSub && oldSub[2]()\n    )\n  }\n  return subs\n}\n\nvar getKey = (vdom) => (vdom == null ? vdom : vdom.key)\n\nvar patchProperty = (node, key, oldValue, newValue, listener, isSvg) => {\n  if (key === \"style\") {\n    for (var k in { ...oldValue, ...newValue }) {\n      oldValue = newValue == null || newValue[k] == null ? \"\" : newValue[k]\n      if (k[0] === \"-\") {\n        node[key].setProperty(k, oldValue)\n      } else {\n        node[key][k] = oldValue\n      }\n    }\n  } else if (key[0] === \"o\" && key[1] === \"n\") {\n    if (\n      !((node.events || (node.events = {}))[(key = key.slice(2))] = newValue)\n    ) {\n      node.removeEventListener(key, listener)\n    } else if (!oldValue) {\n      node.addEventListener(key, listener)\n    }\n  } else if (!isSvg && key !== \"list\" && key !== \"form\" && key in node) {\n    node[key] = newValue == null ? \"\" : newValue\n  } else if (newValue == null || newValue === false) {\n    node.removeAttribute(key)\n  } else {\n    node.setAttribute(key, newValue)\n  }\n}\n\nvar createNode = (vdom, listener, isSvg) => {\n  var props = vdom.props\n  var node =\n    vdom.type === TEXT_NODE\n      ? document.createTextNode(vdom.tag)\n      : (isSvg = isSvg || vdom.tag === \"svg\")\n      ? document.createElementNS(SVG_NS, vdom.tag, props.is && props)\n      : document.createElement(vdom.tag, props.is && props)\n\n  for (var k in props) {\n    patchProperty(node, k, null, props[k], listener, isSvg)\n  }\n\n  for (var i = 0; i < vdom.children.length; i++) {\n    node.appendChild(\n      createNode(\n        (vdom.children[i] = maybeVNode(vdom.children[i])),\n        listener,\n        isSvg\n      )\n    )\n  }\n\n  return (vdom.node = node)\n}\n\nvar patch = (parent, node, oldVNode, newVNode, listener, isSvg) => {\n  if (oldVNode === newVNode) {\n  } else if (\n    oldVNode != null &&\n    oldVNode.type === TEXT_NODE &&\n    newVNode.type === TEXT_NODE\n  ) {\n    if (oldVNode.tag !== newVNode.tag) node.nodeValue = newVNode.tag\n  } else if (oldVNode == null || oldVNode.tag !== newVNode.tag) {\n    node = parent.insertBefore(\n      createNode((newVNode = maybeVNode(newVNode)), listener, isSvg),\n      node\n    )\n    if (oldVNode != null) {\n      parent.removeChild(oldVNode.node)\n    }\n  } else {\n    var tmpVKid\n    var oldVKid\n\n    var oldKey\n    var newKey\n\n    var oldProps = oldVNode.props\n    var newProps = newVNode.props\n\n    var oldVKids = oldVNode.children\n    var newVKids = newVNode.children\n\n    var oldHead = 0\n    var newHead = 0\n    var oldTail = oldVKids.length - 1\n    var newTail = newVKids.length - 1\n\n    isSvg = isSvg || newVNode.tag === \"svg\"\n\n    for (var i in { ...oldProps, ...newProps }) {\n      if (\n        (i === \"value\" || i === \"selected\" || i === \"checked\"\n          ? node[i]\n          : oldProps[i]) !== newProps[i]\n      ) {\n        patchProperty(node, i, oldProps[i], newProps[i], listener, isSvg)\n      }\n    }\n\n    while (newHead <= newTail && oldHead <= oldTail) {\n      if (\n        (oldKey = getKey(oldVKids[oldHead])) == null ||\n        oldKey !== getKey(newVKids[newHead])\n      ) {\n        break\n      }\n\n      patch(\n        node,\n        oldVKids[oldHead].node,\n        oldVKids[oldHead],\n        (newVKids[newHead] = maybeVNode(\n          newVKids[newHead++],\n          oldVKids[oldHead++]\n        )),\n        listener,\n        isSvg\n      )\n    }\n\n    while (newHead <= newTail && oldHead <= oldTail) {\n      if (\n        (oldKey = getKey(oldVKids[oldTail])) == null ||\n        oldKey !== getKey(newVKids[newTail])\n      ) {\n        break\n      }\n\n      patch(\n        node,\n        oldVKids[oldTail].node,\n        oldVKids[oldTail],\n        (newVKids[newTail] = maybeVNode(\n          newVKids[newTail--],\n          oldVKids[oldTail--]\n        )),\n        listener,\n        isSvg\n      )\n    }\n\n    if (oldHead > oldTail) {\n      while (newHead <= newTail) {\n        node.insertBefore(\n          createNode(\n            (newVKids[newHead] = maybeVNode(newVKids[newHead++])),\n            listener,\n            isSvg\n          ),\n          (oldVKid = oldVKids[oldHead]) && oldVKid.node\n        )\n      }\n    } else if (newHead > newTail) {\n      while (oldHead <= oldTail) {\n        node.removeChild(oldVKids[oldHead++].node)\n      }\n    } else {\n      for (var keyed = {}, newKeyed = {}, i = oldHead; i <= oldTail; i++) {\n        if ((oldKey = oldVKids[i].key) != null) {\n          keyed[oldKey] = oldVKids[i]\n        }\n      }\n\n      while (newHead <= newTail) {\n        oldKey = getKey((oldVKid = oldVKids[oldHead]))\n        newKey = getKey(\n          (newVKids[newHead] = maybeVNode(newVKids[newHead], oldVKid))\n        )\n\n        if (\n          newKeyed[oldKey] ||\n          (newKey != null && newKey === getKey(oldVKids[oldHead + 1]))\n        ) {\n          if (oldKey == null) {\n            node.removeChild(oldVKid.node)\n          }\n          oldHead++\n          continue\n        }\n\n        if (newKey == null || oldVNode.type === SSR_NODE) {\n          if (oldKey == null) {\n            patch(\n              node,\n              oldVKid && oldVKid.node,\n              oldVKid,\n              newVKids[newHead],\n              listener,\n              isSvg\n            )\n            newHead++\n          }\n          oldHead++\n        } else {\n          if (oldKey === newKey) {\n            patch(\n              node,\n              oldVKid.node,\n              oldVKid,\n              newVKids[newHead],\n              listener,\n              isSvg\n            )\n            newKeyed[newKey] = true\n            oldHead++\n          } else {\n            if ((tmpVKid = keyed[newKey]) != null) {\n              patch(\n                node,\n                node.insertBefore(tmpVKid.node, oldVKid && oldVKid.node),\n                tmpVKid,\n                newVKids[newHead],\n                listener,\n                isSvg\n              )\n              newKeyed[newKey] = true\n            } else {\n              patch(\n                node,\n                oldVKid && oldVKid.node,\n                null,\n                newVKids[newHead],\n                listener,\n                isSvg\n              )\n            }\n          }\n          newHead++\n        }\n      }\n\n      while (oldHead <= oldTail) {\n        if (getKey((oldVKid = oldVKids[oldHead++])) == null) {\n          node.removeChild(oldVKid.node)\n        }\n      }\n\n      for (var i in keyed) {\n        if (newKeyed[i] == null) {\n          node.removeChild(keyed[i].node)\n        }\n      }\n    }\n  }\n\n  return (newVNode.node = node)\n}\n\nvar propsChanged = (a, b) => {\n  for (var k in a) if (a[k] !== b[k]) return true\n  for (var k in b) if (a[k] !== b[k]) return true\n}\n\nvar maybeVNode = (newVNode, oldVNode) =>\n  newVNode !== true && newVNode !== false && newVNode\n    ? typeof newVNode.tag === \"function\"\n      ? ((!oldVNode ||\n          oldVNode.memo == null ||\n          propsChanged(oldVNode.memo, newVNode.memo)) &&\n          ((oldVNode = newVNode.tag(newVNode.memo)).memo = newVNode.memo),\n        oldVNode)\n      : newVNode\n    : text(\"\")\n\nvar recycleNode = (node) =>\n  node.nodeType === TEXT_NODE\n    ? text(node.nodeValue, node)\n    : createVNode(\n        node.nodeName.toLowerCase(),\n        EMPTY_OBJ,\n        map.call(node.childNodes, recycleNode),\n        SSR_NODE,\n        node\n      )\n\nvar createVNode = (tag, { key, ...props }, children, type, node) => ({\n  tag,\n  props,\n  key,\n  children,\n  type,\n  node,\n})\n\nexport var memo = (tag, memo) => ({ tag, memo })\n\nexport var text = (value, node) =>\n  createVNode(value, EMPTY_OBJ, EMPTY_ARR, TEXT_NODE, node)\n\nexport var h = (tag, { class: c, ...props }, children = EMPTY_ARR) =>\n  createVNode(\n    tag,\n    { ...props, ...(c ? { class: createClass(c) } : EMPTY_OBJ) },\n    isArray(children) ? children : [children]\n  )\n\nexport var app = ({\n  node,\n  view,\n  subscriptions,\n  dispatch = id,\n  init = EMPTY_OBJ,\n}) => {\n  var vdom = node && recycleNode(node)\n  var subs = []\n  var state\n  var busy\n\n  var update = (newState) => {\n    if (state !== newState) {\n      if ((state = newState) == null) dispatch = subscriptions = render = id\n      if (subscriptions) subs = patchSubs(subs, subscriptions(state), dispatch)\n      if (view && !busy) enqueue(render, (busy = true))\n    }\n  }\n\n  var render = () =>\n    (node = patch(\n      node.parentNode,\n      node,\n      vdom,\n      (vdom = view(state)),\n      listener,\n      (busy = false)\n    ))\n\n  var listener = function (event) {\n    dispatch(this.events[event.type], event)\n  }\n\n  return (\n    (dispatch = dispatch((action, props) =>\n      typeof action === \"function\"\n        ? dispatch(action(state, props))\n        : isArray(action)\n        ? typeof action[0] === \"function\"\n          ? dispatch(action[0], action[1])\n          : action\n              .slice(1)\n              .map(\n                (fx) => fx && fx !== true && (fx[0] || fx)(dispatch, fx[1]),\n                update(action[0])\n              )\n        : update(action)\n    ))(init),\n    dispatch\n  )\n}\n","import { h, text, } from 'hyperapp';\nexport default (label, checked, onchange) => h('div', {}, h('label', {}, [\n    text(label),\n    h('input', {\n        type: 'checkbox',\n        checked,\n        onchange,\n    }),\n]));\n","import { h, } from 'hyperapp';\nexport default (action) => (color) => h('input', {\n    style: {\n        width: '36px',\n        verticalAlign: 'middle',\n    },\n    type: 'color',\n    value: color,\n    oninput: action.onchange,\n});\n","import { h, text, } from 'hyperapp';\nexport default (textStyle) => (color) => h('span', {\n    style: {\n        ...textStyle,\n        color,\n    },\n}, text('Aa1あア亜'));\n","/**\n * Tests if a value is a `function`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isFunction } from '@effect/data/Predicate'\n *\n * assert.deepStrictEqual(isFunction(isFunction), true)\n * assert.deepStrictEqual(isFunction(\"function\"), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexport const isFunction = input => typeof input === \"function\";\n/**\n * Creates a function that can be used in a data-last (aka `pipe`able) or\n * data-first style.\n *\n * The first parameter to `dual` is either the arity of the uncurried function\n * or a predicate that determines if the function is being used in a data-first\n * or data-last style.\n *\n * Using the arity is the most common use case, but there are some cases where\n * you may want to use a predicate. For example, if you have a function that\n * takes an optional argument, you can use a predicate to determine if the\n * function is being used in a data-first or data-last style.\n *\n * @param arity - Either the arity of the uncurried function or a predicate\n *                which determines if the function is being used in a data-first\n *                or data-last style.\n * @param body - The definition of the uncurried function.\n *\n * @example\n * import { dual, pipe } from \"@effect/data/Function\"\n *\n * // Exampe using arity to determine data-first or data-last style\n * export const sum: {\n *   (that: number): (self: number) => number\n *   (self: number, that: number): number\n * } = dual(2, (self: number, that: number): number => self + that)\n *\n * assert.deepStrictEqual(sum(2, 3), 5)\n * assert.deepStrictEqual(pipe(2, sum(3)), 5)\n *\n * // Example using a predicate to determine data-first or data-last style\n * export const sum2: {\n *   (that: number): (self: number) => number\n *   (self: number, that: number): number\n * } = dual((args) => args.length === 1, (self: number, that: number): number => self + that)\n *\n * assert.deepStrictEqual(sum(2, 3), 5)\n * assert.deepStrictEqual(pipe(2, sum(3)), 5)\n *\n * @since 1.0.0\n */\nexport const dual = (arity, body) => {\n  const isDataFirst = typeof arity === \"number\" ? args => args.length >= arity : arity;\n  return function () {\n    if (isDataFirst(arguments)) {\n      // @ts-expect-error\n      return body.apply(this, arguments);\n    }\n    return self => body(self, ...arguments);\n  };\n};\n/**\n * Apply a function to a given value.\n *\n * @param a - The value that the function will be applied to.\n * @param self - The function to be applied to a value.\n *\n * @example\n * import { pipe, apply } from \"@effect/data/Function\"\n * import { length } from '@effect/data/String'\n *\n * assert.deepStrictEqual(pipe(length, apply(\"hello\")), 5)\n *\n * @since 1.0.0\n */\nexport const apply = a => self => self(a);\n/**\n * The identity function, i.e. A function that returns its input argument.\n *\n * @param a - The input argument.\n *\n * @example\n * import { identity } from \"@effect/data/Function\"\n *\n * assert.deepStrictEqual(identity(5), 5)\n *\n * @since 1.0.0\n */\nexport const identity = a => a;\n/**\n * Casts the result to the specified type.\n *\n * @param a - The value to be casted to the target type.\n *\n * @example\n * import { unsafeCoerce, identity } from \"@effect/data/Function\"\n *\n * assert.deepStrictEqual(unsafeCoerce, identity)\n *\n * @since 1.0.0\n */\nexport const unsafeCoerce = identity;\n/**\n * Creates a constant value that never changes.\n *\n * This is useful when you want to pass a value to a higher-order function (a function that takes another function as its argument)\n * and want that inner function to always use the same value, no matter how many times it is called.\n *\n * @param value - The constant value to be returned.\n *\n * @example\n * import { constant } from \"@effect/data/Function\"\n *\n * const constNull = constant(null)\n *\n * assert.deepStrictEqual(constNull(), null)\n * assert.deepStrictEqual(constNull(), null)\n *\n * @since 1.0.0\n */\nexport const constant = value => () => value;\n/**\n * A thunk that returns always `true`.\n *\n * @example\n * import { constTrue } from \"@effect/data/Function\"\n *\n * assert.deepStrictEqual(constTrue(), true)\n *\n * @since 1.0.0\n */\nexport const constTrue = /*#__PURE__*/constant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @example\n * import { constFalse } from \"@effect/data/Function\"\n *\n * assert.deepStrictEqual(constFalse(), false)\n *\n * @since 1.0.0\n */\nexport const constFalse = /*#__PURE__*/constant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @example\n * import { constNull } from \"@effect/data/Function\"\n *\n * assert.deepStrictEqual(constNull(), null)\n *\n * @since 1.0.0\n */\nexport const constNull = /*#__PURE__*/constant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @example\n * import { constUndefined } from \"@effect/data/Function\"\n *\n * assert.deepStrictEqual(constUndefined(), undefined)\n *\n * @since 1.0.0\n */\nexport const constUndefined = /*#__PURE__*/constant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @example\n * import { constVoid } from \"@effect/data/Function\"\n *\n * assert.deepStrictEqual(constVoid(), undefined)\n *\n * @since 1.0.0\n */\nexport const constVoid = constUndefined;\n/**\n * Reverses the order of arguments for a curried function.\n *\n * @param f - A curried function that takes multiple arguments.\n *\n * @example\n * import { flip } from \"@effect/data/Function\"\n *\n * const f = (a: number) => (b: string) => a - b.length\n *\n * assert.deepStrictEqual(flip(f)('aaa')(2), -1)\n *\n * @since 1.0.0\n */\nexport const flip = f => (...b) => (...a) => f(...a)(...b);\nexport function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n  switch (arguments.length) {\n    case 1:\n      return ab;\n    case 2:\n      return function () {\n        return bc(ab.apply(this, arguments));\n      };\n    case 3:\n      return function () {\n        return cd(bc(ab.apply(this, arguments)));\n      };\n    case 4:\n      return function () {\n        return de(cd(bc(ab.apply(this, arguments))));\n      };\n    case 5:\n      return function () {\n        return ef(de(cd(bc(ab.apply(this, arguments)))));\n      };\n    case 6:\n      return function () {\n        return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n      };\n    case 7:\n      return function () {\n        return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n      };\n    case 8:\n      return function () {\n        return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n      };\n    case 9:\n      return function () {\n        return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n      };\n  }\n  return;\n}\n/**\n * Composes two functions, `ab` and `bc` into a single function that takes in an argument `a` of type `A` and returns a result of type `C`.\n * The result is obtained by first applying the `ab` function to `a` and then applying the `bc` function to the result of `ab`.\n *\n * @param ab - A function that maps from `A` to `B`.\n * @param bc - A function that maps from `B` to `C`.\n *\n * @example\n * import { compose } from \"@effect/data/Function\"\n *\n * const increment = (n: number) => n + 1;\n * const square = (n: number) => n * n;\n *\n * assert.strictEqual(compose(increment, square)(2), 9);\n *\n * @since 1.0.0\n */\nexport const compose = /*#__PURE__*/dual(2, (ab, bc) => flow(ab, bc));\n/**\n * The `absurd` function is a stub for cases where a value of type `never` is encountered in your code,\n * meaning that it should be impossible for this code to be executed.\n *\n * This function is particularly when it's necessary to specify that certain cases are impossible.\n *\n * @since 1.0.0\n */\nexport const absurd = _ => {\n  throw new Error(\"Called `absurd` function which should be uncallable\");\n};\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from \"@effect/data/Function\"\n *\n * const sumTupled = tupled((x: number, y: number): number => x + y)\n *\n * assert.deepStrictEqual(sumTupled([1, 2]), 3)\n *\n * @since 1.0.0\n */\nexport const tupled = f => a => f(...a);\n/**\n * Inverse function of `tupled`\n *\n * @example\n * import { untupled } from \"@effect/data/Function\"\n *\n * const getFirst = untupled(<A, B>(tuple: [A, B]): A => tuple[0])\n *\n * assert.deepStrictEqual(getFirst(1, 2), 1)\n *\n * @since 1.0.0\n */\nexport const untupled = f => (...a) => f(a);\nexport function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n  switch (arguments.length) {\n    case 1:\n      return a;\n    case 2:\n      return ab(a);\n    case 3:\n      return bc(ab(a));\n    case 4:\n      return cd(bc(ab(a)));\n    case 5:\n      return de(cd(bc(ab(a))));\n    case 6:\n      return ef(de(cd(bc(ab(a)))));\n    case 7:\n      return fg(ef(de(cd(bc(ab(a))))));\n    case 8:\n      return gh(fg(ef(de(cd(bc(ab(a)))))));\n    case 9:\n      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n    default:\n      {\n        let ret = arguments[0];\n        for (let i = 1; i < arguments.length; i++) {\n          ret = arguments[i](ret);\n        }\n        return ret;\n      }\n  }\n}\n/**\n * Type hole simulation.\n *\n * @since 1.0.0\n */\nexport const hole = /*#__PURE__*/unsafeCoerce(absurd);\n/**\n * The SK combinator, also known as the \"S-K combinator\" or \"S-combinator\", is a fundamental combinator in the\n * lambda calculus and the SKI combinator calculus.\n *\n * This function is useful for discarding the first argument passed to it and returning the second argument.\n *\n * @param _ - The first argument to be discarded.\n * @param b - The second argument to be returned.\n *\n * @example\n * import { SK } from \"@effect/data/Function\";\n *\n * assert.deepStrictEqual(SK(0, \"hello\"), \"hello\")\n *\n * @since 1.0.0\n */\nexport const SK = (_, b) => b;\n//# sourceMappingURL=Function.mjs.map","/**\n * @since 1.0.0\n */\nconst globalStoreId = /*#__PURE__*/Symbol.for(\"@effect/data/Global/globalStoreId\");\nif (!(globalStoreId in globalThis)) {\n  ;\n  globalThis[globalStoreId] = /*#__PURE__*/new Map();\n}\nconst globalStore = globalThis[globalStoreId];\n/**\n * @since 1.0.0\n */\nexport const globalValue = (id, compute) => {\n  if (!globalStore.has(id)) {\n    globalStore.set(id, compute());\n  }\n  return globalStore.get(id);\n};\n//# sourceMappingURL=Global.mjs.map","/*\n * Copyright 2014 Thom Chiovoloni, released under the MIT license.\n *\n * A random number generator based on the basic implementation of the PCG algorithm,\n * as described here: http://www.pcg-random.org/\n *\n * Adapted for TypeScript from Thom's original code at https://github.com/thomcc/pcg-random\n *\n * forked from https://github.com/frptools\n *\n * @since 1.0.0\n */\n/** @internal */\nexport function isNothing(value) {\n  return value === void 0 || value === null;\n}\nconst defaultIncHi = 0x14057b7e;\nconst defaultIncLo = 0xf767814f;\nconst MUL_HI = 0x5851f42d >>> 0;\nconst MUL_LO = 0x4c957f2d >>> 0;\nconst BIT_53 = 9007199254740992.0;\nconst BIT_27 = 134217728.0;\n/**\n * PCG is a family of simple fast space-efficient statistically good algorithms\n * for random number generation. Unlike many general-purpose RNGs, they are also\n * hard to predict.\n *\n * @category model\n * @since 1.0.0\n */\nexport class PCGRandom {\n  constructor(seedHi, seedLo, incHi, incLo) {\n    if (isNothing(seedLo) && isNothing(seedHi)) {\n      seedLo = Math.random() * 0xffffffff >>> 0;\n      seedHi = 0;\n    } else if (isNothing(seedLo)) {\n      seedLo = seedHi;\n      seedHi = 0;\n    }\n    if (isNothing(incLo) && isNothing(incHi)) {\n      // @ts-expect-error\n      incLo = this._state ? this._state[3] : defaultIncLo;\n      // @ts-expect-error\n      incHi = this._state ? this._state[2] : defaultIncHi;\n    } else if (isNothing(incLo)) {\n      incLo = incHi;\n      incHi = 0;\n    }\n    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);\n    this._next();\n    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);\n    this._next();\n    return this;\n  }\n  /**\n   * Returns a copy of the internal state of this random number generator as a\n   * JavaScript Array.\n   *\n   * @category getters\n   * @since 1.0.0\n   */\n  getState() {\n    return [this._state[0], this._state[1], this._state[2], this._state[3]];\n  }\n  /**\n   * Restore state previously retrieved using `getState()`.\n   *\n   * @category utils\n   * @since 1.0.0\n   */\n  setState(state) {\n    this._state[0] = state[0];\n    this._state[1] = state[1];\n    this._state[2] = state[2];\n    this._state[3] = state[3] | 1;\n  }\n  /**\n   * Get a uniformly distributed 32 bit integer between [0, max).\n   *\n   * @category getter\n   * @since 1.0.0\n   */\n  integer(max) {\n    if (!max) {\n      return this._next();\n    }\n    max = max >>> 0;\n    if ((max & max - 1) === 0) {\n      return this._next() & max - 1; // fast path for power of 2\n    }\n\n    let num = 0;\n    const skew = (-max >>> 0) % max >>> 0;\n    for (num = this._next(); num < skew; num = this._next()) {\n      // this loop will rarely execute more than twice,\n      // and is intentionally empty\n    }\n    return num % max;\n  }\n  /**\n   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with\n   * 53 bits of precision (every bit of the mantissa is randomized).\n   *\n   * @category getters\n   * @since 1.0.0\n   */\n  number() {\n    const hi = (this._next() & 0x03ffffff) * 1.0;\n    const lo = (this._next() & 0x07ffffff) * 1.0;\n    return (hi * BIT_27 + lo) / BIT_53;\n  }\n  /** @internal */\n  _next() {\n    // save current state (what we'll use for this number)\n    const oldHi = this._state[0] >>> 0;\n    const oldLo = this._state[1] >>> 0;\n    // churn LCG.\n    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);\n    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);\n    // get least sig. 32 bits of ((oldstate >> 18) ^ oldstate) >> 27\n    let xsHi = oldHi >>> 18;\n    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;\n    xsHi = (xsHi ^ oldHi) >>> 0;\n    xsLo = (xsLo ^ oldLo) >>> 0;\n    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;\n    // rotate xorshifted right a random amount, based on the most sig. 5 bits\n    // bits of the old state.\n    const rot = oldHi >>> 27;\n    const rot2 = (-rot >>> 0 & 31) >>> 0;\n    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;\n  }\n}\nfunction mul64(out, aHi, aLo, bHi, bLo) {\n  let c1 = (aLo >>> 16) * (bLo & 0xffff) >>> 0;\n  let c0 = (aLo & 0xffff) * (bLo >>> 16) >>> 0;\n  let lo = (aLo & 0xffff) * (bLo & 0xffff) >>> 0;\n  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;\n  c0 = c0 << 16 >>> 0;\n  lo = lo + c0 >>> 0;\n  if (lo >>> 0 < c0 >>> 0) {\n    hi = hi + 1 >>> 0;\n  }\n  c1 = c1 << 16 >>> 0;\n  lo = lo + c1 >>> 0;\n  if (lo >>> 0 < c1 >>> 0) {\n    hi = hi + 1 >>> 0;\n  }\n  hi = hi + Math.imul(aLo, bHi) >>> 0;\n  hi = hi + Math.imul(aHi, bLo) >>> 0;\n  out[0] = hi;\n  out[1] = lo;\n}\n// add two 64 bit numbers (given in parts), and store the result in `out`.\nfunction add64(out, aHi, aLo, bHi, bLo) {\n  let hi = aHi + bHi >>> 0;\n  const lo = aLo + bLo >>> 0;\n  if (lo >>> 0 < aLo >>> 0) {\n    hi = hi + 1 | 0;\n  }\n  out[0] = hi;\n  out[1] = lo;\n}\n//# sourceMappingURL=Random.mjs.map","/**\n * @since 1.0.0\n */\n\nimport { globalValue } from \"@effect/data/Global\";\nimport { PCGRandom } from \"@effect/data/Random\";\n/** @internal */\nconst randomHashCache = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"@effect/data/Hash/randomHashCache\"), () => new WeakMap());\n/** @internal */\nconst pcgr = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"@effect/data/Hash/pcgr\"), () => new PCGRandom());\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const symbol = /*#__PURE__*/Symbol.for(\"@effect/data/Hash\");\n/**\n * @since 1.0.0\n * @category hashing\n */\nexport const hash = self => {\n  switch (typeof self) {\n    case \"number\":\n      {\n        return number(self);\n      }\n    case \"bigint\":\n      {\n        return string(self.toString(10));\n      }\n    case \"boolean\":\n      {\n        return string(String(self));\n      }\n    case \"symbol\":\n      {\n        return string(String(self));\n      }\n    case \"string\":\n      {\n        return string(self);\n      }\n    case \"undefined\":\n      {\n        return string(\"undefined\");\n      }\n    case \"function\":\n    case \"object\":\n      {\n        if (self === null) {\n          return string(\"null\");\n        }\n        if (isHash(self)) {\n          return self[symbol]();\n        } else {\n          return random(self);\n        }\n      }\n    default:\n      {\n        throw new Error(\"Bug in Equal.hashGeneric\");\n      }\n  }\n};\n/**\n * @since 1.0.0\n * @category hashing\n */\nexport const random = self => {\n  if (!randomHashCache.has(self)) {\n    randomHashCache.set(self, number(pcgr.integer(Number.MAX_SAFE_INTEGER)));\n  }\n  return randomHashCache.get(self);\n};\n/**\n * @since 1.0.0\n * @category hashing\n */\nexport const combine = b => self => self * 53 ^ b;\n/**\n * @since 1.0.0\n * @category hashing\n */\nexport const optimize = n => n & 0xbfffffff | n >>> 1 & 0x40000000;\n/**\n * @since 1.0.0\n * @category guards\n */\nexport const isHash = u => typeof u === \"object\" && u !== null && symbol in u;\n/**\n * @since 1.0.0\n * @category hashing\n */\nexport const number = n => {\n  if (n !== n || n === Infinity) {\n    return 0;\n  }\n  let h = n | 0;\n  if (h !== n) {\n    h ^= n * 0xffffffff;\n  }\n  while (n > 0xffffffff) {\n    h ^= n /= 0xffffffff;\n  }\n  return optimize(n);\n};\n/**\n * @since 1.0.0\n * @category hashing\n */\nexport const string = str => {\n  let h = 5381,\n    i = str.length;\n  while (i) {\n    h = h * 33 ^ str.charCodeAt(--i);\n  }\n  return optimize(h);\n};\n/**\n * @since 1.0.0\n * @category hashing\n */\nexport const structure = o => {\n  const keys = Object.keys(o);\n  let h = 12289;\n  for (let i = 0; i < keys.length; i++) {\n    h ^= combine(hash(o[keys[i]]))(string(keys[i]));\n  }\n  return optimize(h);\n};\n/**\n * @since 1.0.0\n * @category hashing\n */\nexport const array = arr => {\n  let h = 6151;\n  for (let i = 0; i < arr.length; i++) {\n    h = combine(hash(arr[i]))(h);\n  }\n  return optimize(h);\n};\n//# sourceMappingURL=Hash.mjs.map","/**\n * @since 1.0.0\n */\nimport * as Hash from \"@effect/data/Hash\";\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const symbol = /*#__PURE__*/Symbol.for(\"@effect/data/Equal\");\nexport function equals() {\n  if (arguments.length === 1) {\n    return self => compareBoth(self, arguments[0]);\n  }\n  return compareBoth(arguments[0], arguments[1]);\n}\nfunction compareBoth(self, that) {\n  if (self === that) {\n    return true;\n  }\n  const selfType = typeof self;\n  if (selfType !== typeof that) {\n    return false;\n  }\n  if ((selfType === \"object\" || selfType === \"function\") && self !== null && that !== null) {\n    if (isEqual(self) && isEqual(that)) {\n      return Hash.hash(self) === Hash.hash(that) && self[symbol](that);\n    }\n  }\n  return false;\n}\n/**\n * @since 1.0.0\n * @category guards\n */\nexport const isEqual = u => typeof u === \"object\" && u !== null && symbol in u;\n/**\n * @since 1.0.0\n * @category instances\n */\nexport const equivalence = () => (self, that) => Hash.hash(self) === Hash.hash(that) && equals(self, that);\n//# sourceMappingURL=Equal.mjs.map","/**\n * @since 1.0.0\n */\nvar _a;\nimport * as Equal from \"@effect/data/Equal\";\nimport { globalValue } from \"@effect/data/Global\";\nimport * as Hash from \"@effect/data/Hash\";\n/**\n * @since 1.0.0\n * @category debug\n */\nexport const runtimeDebug = /*#__PURE__*/globalValue( /*#__PURE__*/Symbol.for(\"@effect/data/Debug/runtimeDebug\"), () => ({\n  reportUnhandled: true,\n  minumumLogLevel: \"Info\",\n  traceStackLimit: 5,\n  tracingEnabled: true,\n  parseStack: error => {\n    const stack = error.stack;\n    if (stack) {\n      const lines = stack.split(\"\\n\");\n      let starts = 0;\n      for (let i = 0; i < lines.length; i++) {\n        if (lines[i].startsWith(\"Error\")) {\n          starts = i;\n        }\n      }\n      const frames = [];\n      for (let i = starts + 1; i < lines.length; i++) {\n        if (lines[i].includes(\"at\")) {\n          const blocks = lines[i].split(\" \").filter(i => i.length > 0 && i !== \"at\");\n          const name = blocks.length === 2 && !blocks[0].includes(\"<anonymous>\") ? blocks[0] : undefined;\n          const file = blocks.length === 2 ? blocks[1] : blocks[0];\n          const matchFrame = file?.match(/\\(?(.*):(\\d+):(\\d+)/);\n          if (matchFrame) {\n            frames.push({\n              name,\n              fileName: matchFrame[1],\n              line: Number.parseInt(matchFrame[2]),\n              column: Number.parseInt(matchFrame[3])\n            });\n          } else {\n            frames.push(undefined);\n          }\n        } else {\n          frames.push(undefined);\n        }\n      }\n      return frames;\n    }\n    return [];\n  },\n  filterStackFrame: _ => _ != null && !_.fileName.match(/\\/internal_effect_untraced/)\n}));\nconst sourceLocationProto = /*#__PURE__*/Object.setPrototypeOf({\n  toFrame() {\n    if (\"parsed\" in this) {\n      return this.parsed;\n    }\n    const stack = runtimeDebug.parseStack(this);\n    if (stack && stack.length >= 2 && stack[0] && stack[1]) {\n      this.parsed = {\n        ...stack[this.depth - 1],\n        name: stack[this.depth - 2]?.name\n      };\n    } else {\n      this.parsed = undefined;\n    }\n    return this.parsed;\n  }\n}, Error.prototype);\n/**\n * @since 1.0.0\n * @category tracing\n */\nexport const sourceLocation = error => {\n  ;\n  error.depth = Error.stackTraceLimit;\n  Object.setPrototypeOf(error, sourceLocationProto);\n  return error;\n};\n/**\n * @since 1.0.0\n * @category tracing\n */\nexport const bodyWithTrace = body => {\n  if (!runtimeDebug.tracingEnabled) {\n    return body(void 0, restoreOff);\n  }\n  runtimeDebug.tracingEnabled = false;\n  try {\n    const limit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 3;\n    const source = sourceLocation(new Error());\n    Error.stackTraceLimit = limit;\n    return body(source, restoreOn);\n  } finally {\n    runtimeDebug.tracingEnabled = true;\n  }\n};\n/**\n * @since 1.0.0\n * @category tracing\n */\nexport const methodWithTrace = body => {\n  // @ts-expect-error\n  return function () {\n    if (!runtimeDebug.tracingEnabled) {\n      // @ts-expect-error\n      return body(void 0, restoreOff).apply(this, arguments);\n    }\n    runtimeDebug.tracingEnabled = false;\n    try {\n      const limit = Error.stackTraceLimit;\n      Error.stackTraceLimit = 2;\n      const error = sourceLocation(new Error());\n      Error.stackTraceLimit = limit;\n      // @ts-expect-error\n      return body(error, restoreOn).apply(this, arguments);\n    } finally {\n      runtimeDebug.tracingEnabled = true;\n    }\n  };\n};\n/**\n * @since 1.0.0\n * @category tracing\n */\nexport const pipeableWithTrace = body => {\n  // @ts-expect-error\n  return function () {\n    if (!runtimeDebug.tracingEnabled) {\n      const a = body(void 0, restoreOff);\n      // @ts-expect-error\n      return self => untraced(() => a.apply(this, arguments)(self));\n    }\n    runtimeDebug.tracingEnabled = false;\n    try {\n      const limit = Error.stackTraceLimit;\n      Error.stackTraceLimit = 2;\n      const source = sourceLocation(new Error());\n      Error.stackTraceLimit = limit;\n      const f = body(source, restoreOn);\n      // @ts-expect-error\n      return self => untraced(() => f.apply(this, arguments)(self));\n    } finally {\n      runtimeDebug.tracingEnabled = true;\n    }\n  };\n};\n/**\n * @since 1.0.0\n * @category tracing\n */\nexport const dualWithTrace = (dfLen, body) => {\n  const isDataFirst = typeof dfLen === \"number\" ? args => args.length === dfLen : dfLen;\n  return function () {\n    if (!runtimeDebug.tracingEnabled) {\n      const f = body(void 0, restoreOff);\n      if (isDataFirst(arguments)) {\n        // @ts-expect-error\n        return untraced(() => f.apply(this, arguments));\n      }\n      return self => untraced(() => f(self, ...arguments));\n    }\n    runtimeDebug.tracingEnabled = false;\n    try {\n      const limit = Error.stackTraceLimit;\n      Error.stackTraceLimit = 2;\n      const source = sourceLocation(new Error());\n      Error.stackTraceLimit = limit;\n      const f = body(source, restoreOn);\n      if (isDataFirst(arguments)) {\n        // @ts-expect-error\n        return untraced(() => f.apply(this, arguments));\n      }\n      return self => untraced(() => f(self, ...arguments));\n    } finally {\n      runtimeDebug.tracingEnabled = true;\n    }\n  };\n};\n/**\n * @since 1.0.0\n * @category tracing\n */\nexport const untraced = body => {\n  if (!runtimeDebug.tracingEnabled) {\n    return body(restoreOff);\n  }\n  runtimeDebug.tracingEnabled = false;\n  try {\n    return body(restoreOn);\n  } finally {\n    runtimeDebug.tracingEnabled = true;\n  }\n};\n/**\n * @since 1.0.0\n * @category tracing\n */\nexport const untracedDual = (dfLen, body) => {\n  // @ts-expect-error\n  return function () {\n    if (!runtimeDebug.tracingEnabled) {\n      const f = body(restoreOff);\n      if (arguments.length === dfLen) {\n        // @ts-expect-error\n        return untraced(() => f.apply(this, arguments));\n      }\n      return self => untraced(() => f(self, ...arguments));\n    }\n    runtimeDebug.tracingEnabled = false;\n    try {\n      const f = body(restoreOn);\n      if (arguments.length === dfLen) {\n        // @ts-expect-error\n        return untraced(() => f.apply(this, arguments));\n      }\n      return self => untraced(() => f(self, ...arguments));\n    } finally {\n      runtimeDebug.tracingEnabled = true;\n    }\n  };\n};\n/**\n * @since 1.0.0\n * @category tracing\n */\nexport const untracedMethod = body => {\n  // @ts-expect-error\n  return function () {\n    if (!runtimeDebug.tracingEnabled) {\n      // @ts-expect-error\n      return untraced(() => body(restoreOff).apply(this, arguments));\n    }\n    runtimeDebug.tracingEnabled = false;\n    try {\n      // @ts-expect-error\n      return untraced(() => body(restoreOn).apply(this, arguments));\n    } finally {\n      runtimeDebug.tracingEnabled = true;\n    }\n  };\n};\n/**\n * @since 1.0.0\n * @category tracing\n */\nexport const traced = body => {\n  if (runtimeDebug.tracingEnabled) {\n    return body(restoreOn);\n  }\n  runtimeDebug.tracingEnabled = true;\n  try {\n    return body(restoreOff);\n  } finally {\n    runtimeDebug.tracingEnabled = false;\n  }\n};\n/**\n * @since 1.0.0\n * @category restore\n */\nexport const restoreOn = body => function () {\n  if (runtimeDebug.tracingEnabled) {\n    // @ts-expect-error\n    return body.apply(this, arguments);\n  }\n  runtimeDebug.tracingEnabled = true;\n  try {\n    // @ts-expect-error\n    return body.apply(this, arguments);\n  } finally {\n    runtimeDebug.tracingEnabled = false;\n  }\n};\n/**\n * @since 1.0.0\n * @category restore\n */\nexport const restoreOff = body => function () {\n  if (!runtimeDebug.tracingEnabled) {\n    // @ts-expect-error\n    return body.apply(this, arguments);\n  }\n  runtimeDebug.tracingEnabled = false;\n  try {\n    // @ts-expect-error\n    return body.apply(this, arguments);\n  } finally {\n    runtimeDebug.tracingEnabled = true;\n  }\n};\nconst EffectTypeId = /*#__PURE__*/Symbol.for(\"@effect/io/Effect\");\nclass TracedPrimitive {\n  [(_a = EffectTypeId, Equal.symbol)](that) {\n    return this === that;\n  }\n  [Hash.symbol]() {\n    return Hash.random(this);\n  }\n  constructor(i0, trace) {\n    this.i0 = i0;\n    this.trace = trace;\n    this._tag = \"Traced\";\n    this.i1 = undefined;\n    this.i2 = undefined;\n    this[_a] = effectVariance;\n  }\n  traced(trace) {\n    if (trace) {\n      return new TracedPrimitive(this, trace);\n    }\n    return this;\n  }\n}\n/** @internal */\nconst effectVariance = {\n  _R: _ => _,\n  _E: _ => _,\n  _A: _ => _\n};\n/**\n * @since 1.0.0\n * @category tracing\n */\nexport const makeTraced = (self, source) => new TracedPrimitive(self, source);\n//# sourceMappingURL=Debug.mjs.map","/**\n * @since 1.0.0\n */\nvar _a, _b;\nimport { makeTraced } from \"@effect/data/Debug\";\nimport * as Equal from \"@effect/data/Equal\";\nimport * as Hash from \"@effect/data/Hash\";\n/** @internal */\nconst effectVariance = {\n  _R: _ => _,\n  _E: _ => _,\n  _A: _ => _\n};\nconst EffectTypeId = /*#__PURE__*/Symbol.for(\"@effect/io/Effect\");\nconst OptionTypeId = /*#__PURE__*/Symbol.for(\"@effect/io/Option\");\n/** @internal */\nexport class Some {\n  [(_a = EffectTypeId, Equal.symbol)](that) {\n    return isOption(that) && isSome(that) && Equal.equals(that.i0, this.i0);\n  }\n  [Hash.symbol]() {\n    return Hash.hash(this.i0);\n  }\n  toString() {\n    return `some(${String(this.i0)})`;\n  }\n  toJSON() {\n    return {\n      _tag: this._tag,\n      value: this.i0\n    };\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toJSON();\n  }\n  get [OptionTypeId]() {\n    return {\n      _A: _ => _\n    };\n  }\n  get value() {\n    return this.i0;\n  }\n  constructor(i0) {\n    this.i0 = i0;\n    this._tag = \"Some\";\n    this.i1 = undefined;\n    this.i2 = undefined;\n    this.trace = undefined;\n    this[_a] = effectVariance;\n  }\n  traced(trace) {\n    if (trace) {\n      return makeTraced(this, trace);\n    }\n    return this;\n  }\n}\n/** @internal */\nexport class None {\n  constructor() {\n    this._tag = \"None\";\n    this.i0 = undefined;\n    this.i1 = undefined;\n    this.i2 = undefined;\n    this.trace = undefined;\n    this[_b] = effectVariance;\n  }\n  [(_b = EffectTypeId, Equal.symbol)](that) {\n    return isOption(that) && isNone(that);\n  }\n  [Hash.symbol]() {\n    return Hash.hash(this._tag);\n  }\n  toString() {\n    return `none()`;\n  }\n  toJSON() {\n    return {\n      _tag: this._tag\n    };\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toJSON();\n  }\n  get [OptionTypeId]() {\n    return {\n      _A: _ => _\n    };\n  }\n  traced(trace) {\n    if (trace) {\n      return makeTraced(this, trace);\n    }\n    return this;\n  }\n}\n/** @internal */\nexport const isOption = input => typeof input === \"object\" && input != null && \"_tag\" in input && (input[\"_tag\"] === \"None\" || input[\"_tag\"] === \"Some\") && Equal.isEqual(input);\n/** @internal */\nexport const isNone = fa => fa._tag === \"None\";\n/** @internal */\nexport const isSome = fa => fa._tag === \"Some\";\n/** @internal */\nexport const none = /*#__PURE__*/new None();\n/** @internal */\nexport const some = a => new Some(a);\n//# sourceMappingURL=Option.mjs.map","/**\n * @since 1.0.0\n */\nvar _a, _b;\nimport { makeTraced } from \"@effect/data/Debug\";\nimport * as Equal from \"@effect/data/Equal\";\nimport { dual } from \"@effect/data/Function\";\nimport * as Hash from \"@effect/data/Hash\";\nimport * as option from \"@effect/data/internal/Option\";\n/** @internal */\nconst effectVariance = {\n  _R: _ => _,\n  _E: _ => _,\n  _A: _ => _\n};\nconst EffectTypeId = /*#__PURE__*/Symbol.for(\"@effect/io/Effect\");\nconst EitherTypeId = /*#__PURE__*/Symbol.for(\"@effect/data/Either\");\n/** @internal */\nexport class Right {\n  [(_a = EffectTypeId, Equal.symbol)](that) {\n    return isEither(that) && isRight(that) && Equal.equals(that.i0, this.i0);\n  }\n  [Hash.symbol]() {\n    return Hash.hash(this.i0);\n  }\n  get right() {\n    return this.i0;\n  }\n  constructor(i0) {\n    this.i0 = i0;\n    this._tag = \"Right\";\n    this.i1 = undefined;\n    this.i2 = undefined;\n    this.trace = undefined;\n    this[_a] = effectVariance;\n  }\n  get [EitherTypeId]() {\n    return {\n      _E: _ => _,\n      _A: _ => _\n    };\n  }\n  toString() {\n    return `right(${String(this.i0)})`;\n  }\n  toJSON() {\n    return {\n      _tag: this._tag,\n      right: this.i0\n    };\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toJSON();\n  }\n  traced(trace) {\n    if (trace) {\n      return makeTraced(this, trace);\n    }\n    return this;\n  }\n}\n/** @internal */\nexport class Left {\n  [(_b = EffectTypeId, Equal.symbol)](that) {\n    return isEither(that) && isLeft(that) && Equal.equals(that.i0, this.i0);\n  }\n  [Hash.symbol]() {\n    return Hash.hash(this.i0);\n  }\n  get [EitherTypeId]() {\n    return {\n      _E: _ => _,\n      _A: _ => _\n    };\n  }\n  get left() {\n    return this.i0;\n  }\n  constructor(i0) {\n    this.i0 = i0;\n    this._tag = \"Left\";\n    this.i1 = undefined;\n    this.i2 = undefined;\n    this.trace = undefined;\n    this[_b] = effectVariance;\n  }\n  toString() {\n    return `left(${String(this.i0)})`;\n  }\n  toJSON() {\n    return {\n      _tag: this._tag,\n      left: this.i0\n    };\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toJSON();\n  }\n  traced(trace) {\n    if (trace) {\n      return makeTraced(this, trace);\n    }\n    return this;\n  }\n}\n/** @internal */\nexport const isEither = input => typeof input === \"object\" && input != null && \"_tag\" in input && (input[\"_tag\"] === \"Left\" || input[\"_tag\"] === \"Right\") && Equal.isEqual(input);\n/** @internal */\nexport const isLeft = ma => ma._tag === \"Left\";\n/** @internal */\nexport const isRight = ma => ma._tag === \"Right\";\n/** @internal */\nexport const left = e => new Left(e);\n/** @internal */\nexport const right = a => new Right(a);\n/** @internal */\nexport const getLeft = self => isRight(self) ? option.none : option.some(self.left);\n/** @internal */\nexport const getRight = self => isLeft(self) ? option.none : option.some(self.right);\n/** @internal */\nexport const fromOption = /*#__PURE__*/dual(2, (self, onNone) => option.isNone(self) ? left(onNone()) : right(self.value));\n//# sourceMappingURL=Either.mjs.map","/**\n * @since 1.0.0\n */\nimport { dual } from \"@effect/data/Function\";\nimport * as contravariant from \"@effect/data/typeclass/Contravariant\";\nimport * as monoid from \"@effect/data/typeclass/Monoid\";\nimport * as product_ from \"@effect/data/typeclass/Product\";\nimport * as semigroup from \"@effect/data/typeclass/Semigroup\";\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const make = compare => ({\n  compare: (self, that) => self === that ? 0 : compare(self, that)\n});\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const string = /*#__PURE__*/make((self, that) => self < that ? -1 : 1);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const number = /*#__PURE__*/make((self, that) => self < that ? -1 : 1);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const boolean = /*#__PURE__*/make((self, that) => self < that ? -1 : 1);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const bigint = /*#__PURE__*/make((self, that) => self < that ? -1 : 1);\n/**\n * @since 1.0.0\n */\nexport const reverse = O => make((self, that) => O.compare(that, self));\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const getSemigroup = () => semigroup.make((O1, O2) => make((self, that) => {\n  const out = O1.compare(self, that);\n  if (out !== 0) {\n    return out;\n  }\n  return O2.compare(self, that);\n}), (self, collection) => make((a1, a2) => {\n  let out = self.compare(a1, a2);\n  if (out !== 0) {\n    return out;\n  }\n  for (const O of collection) {\n    out = O.compare(a1, a2);\n    if (out !== 0) {\n      return out;\n    }\n  }\n  return out;\n}));\nconst empty = /*#__PURE__*/make(() => 0);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const getMonoid = () => monoid.fromSemigroup(getSemigroup(), empty);\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport const contramap = /*#__PURE__*/dual(2, (self, f) => make((b1, b2) => self.compare(f(b1), f(b2))));\nconst imap = /*#__PURE__*/contravariant.imap(contramap);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Contravariant = {\n  imap,\n  contramap\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Invariant = {\n  imap\n};\nconst product = (self, that) => make(([xa, xb], [ya, yb]) => {\n  const o = self.compare(xa, ya);\n  return o !== 0 ? o : that.compare(xb, yb);\n});\nconst productAll = collection => {\n  return make((x, y) => {\n    const len = Math.min(x.length, y.length);\n    let collectionLength = 0;\n    for (const order of collection) {\n      if (collectionLength >= len) {\n        break;\n      }\n      const o = order.compare(x[collectionLength], y[collectionLength]);\n      if (o !== 0) {\n        return o;\n      }\n      collectionLength++;\n    }\n    return 0;\n  });\n};\nconst productMany = (self, collection) => {\n  const order = productAll(collection);\n  return make((x, y) => {\n    const o = self.compare(x[0], y[0]);\n    return o !== 0 ? o : order.compare(x.slice(1), y.slice(1));\n  });\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const SemiProduct = {\n  imap,\n  product,\n  productMany\n};\nconst of = () => empty;\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Product = {\n  of,\n  imap,\n  product,\n  productMany,\n  productAll\n};\n/**\n * Similar to `Promise.all` but operates on `Order`s.\n *\n * ```\n * [Order<A>, Order<B>, ...] -> Order<[A, B, ...]>\n * ```\n *\n * This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.\n * The returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.\n * It is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element\n * of the tuple.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const tuple = /*#__PURE__*/product_.tuple(Product);\n/**\n * This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.\n * The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.\n * If all elements are equal, the arrays are then compared based on their length.\n * It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const array = O => make((self, that) => {\n  const aLen = self.length;\n  const bLen = that.length;\n  const len = Math.min(aLen, bLen);\n  for (let i = 0; i < len; i++) {\n    const o = O.compare(self[i], that[i]);\n    if (o !== 0) {\n      return o;\n    }\n  }\n  return number.compare(aLen, bLen);\n});\n/**\n * This function creates and returns a new `Order` for a struct of values based on the given `Order`s\n * for each property in the struct.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const struct = /*#__PURE__*/product_.struct(Product);\n/**\n * Test whether one value is _strictly less than_ another.\n *\n * @since 1.0.0\n */\nexport const lessThan = O => dual(2, (self, that) => O.compare(self, that) === -1);\n/**\n * Test whether one value is _strictly greater than_ another.\n *\n * @since 1.0.0\n */\nexport const greaterThan = O => dual(2, (self, that) => O.compare(self, that) === 1);\n/**\n * Test whether one value is _non-strictly less than_ another.\n *\n * @since 1.0.0\n */\nexport const lessThanOrEqualTo = O => dual(2, (self, that) => O.compare(self, that) !== 1);\n/**\n * Test whether one value is _non-strictly greater than_ another.\n *\n * @since 1.0.0\n */\nexport const greaterThanOrEqualTo = O => dual(2, (self, that) => O.compare(self, that) !== -1);\n/**\n * Take the minimum of two values. If they are considered equal, the first argument is chosen.\n *\n * @since 1.0.0\n */\nexport const min = O => dual(2, (self, that) => self === that || O.compare(self, that) < 1 ? self : that);\n/**\n * Take the maximum of two values. If they are considered equal, the first argument is chosen.\n *\n * @since 1.0.0\n */\nexport const max = O => dual(2, (self, that) => self === that || O.compare(self, that) > -1 ? self : that);\n/**\n * Clamp a value between a minimum and a maximum.\n *\n * @since 1.0.0\n */\nexport const clamp = O => dual(3, (self, minimum, maximum) => min(O)(maximum, max(O)(minimum, self)));\n/**\n * Test whether a value is between a minimum and a maximum (inclusive).\n *\n * @since 1.0.0\n */\nexport const between = O => dual(3, (self, minimum, maximum) => !lessThan(O)(self, minimum) && !greaterThan(O)(self, maximum));\n//# sourceMappingURL=Order.mjs.map","import * as monoid from \"@effect/data/typeclass/Monoid\";\nimport * as order from \"@effect/data/typeclass/Order\";\nimport * as semigroup from \"@effect/data/typeclass/Semigroup\";\n/**\n * `Monoid` that returns last minimum of elements.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const min = B => monoid.fromSemigroup(semigroup.min(B), B.maxBound);\n/**\n * `Monoid` that returns last maximum of elements.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const max = B => monoid.fromSemigroup(semigroup.max(B), B.minBound);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const number = {\n  compare: order.number.compare,\n  maxBound: Infinity,\n  minBound: -Infinity\n};\n/**\n * Checks if a value is between the lower and upper limit of a bound.\n *\n * @category predicates\n * @since 1.0.0\n */\nexport const between = B => order.between(B)(B.minBound, B.maxBound);\n/**\n * Clamp a value between `minBound` and `maxBound` values.\n *\n * @category utils\n * @since 1.0.0\n */\nexport const clamp = B => order.clamp(B)(B.minBound, B.maxBound);\n/**\n * Reverses the `Order` of a `Bounded` and flips `maxBound` and `minBound` values.\n *\n * @category utils\n * @since 1.0.0\n */\nexport const reverse = B => ({\n  ...order.reverse(B),\n  minBound: B.maxBound,\n  maxBound: B.minBound\n});\n//# sourceMappingURL=Bounded.mjs.map","/**\n * @since 1.0.0\n */\nimport { dual } from \"@effect/data/Function\";\nimport { map, reduce } from \"@effect/data/internal/Iterable\";\nimport * as product_ from \"@effect/data/typeclass/Product\";\n/**\n * @param combineMany - Useful when `combineMany` can be optimised\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const make = (combine, combineMany = (self, collection) => reduce(self, combine)(collection)) => ({\n  combine,\n  combineMany\n});\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const string = /*#__PURE__*/make((self, that) => self + that);\n/**\n * `number` semigroup under addition.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const numberSum = /*#__PURE__*/make((self, that) => self + that);\n/**\n * `number` semigroup under multiplication.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const numberMultiply = /*#__PURE__*/make((self, that) => self * that, (self, collection) => {\n  if (self === 0) {\n    return 0;\n  }\n  let out = self;\n  for (const n of collection) {\n    if (n === 0) {\n      return 0;\n    }\n    out = out * n;\n  }\n  return out;\n});\n/**\n * `bigint` semigroup under addition.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const bigintSum = /*#__PURE__*/make((self, that) => self + that);\n/**\n * `bigint` semigroup under multiplication.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const bigintMultiply = /*#__PURE__*/make((self, that) => self * that, (self, collection) => {\n  if (self === 0n) {\n    return 0n;\n  }\n  let out = self;\n  for (const n of collection) {\n    if (n === 0n) {\n      return 0n;\n    }\n    out = out * n;\n  }\n  return out;\n});\n/**\n * `boolean` semigroup under conjunction.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const booleanEvery = /*#__PURE__*/make((self, that) => self && that, (self, collection) => {\n  if (self === false) {\n    return false;\n  }\n  for (const b of collection) {\n    if (b === false) {\n      return false;\n    }\n  }\n  return true;\n});\n/**\n * `boolean` semigroup under disjunction.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const booleanSome = /*#__PURE__*/make((self, that) => self || that, (self, collection) => {\n  if (self === true) {\n    return true;\n  }\n  for (const b of collection) {\n    if (b === true) {\n      return true;\n    }\n  }\n  return false;\n});\n/**\n * `boolean` semigroup under exclusive disjunction.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const booleanXor = /*#__PURE__*/make((self, that) => self !== that);\n/**\n * `boolean` semigroup under equivalence.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const booleanEqv = /*#__PURE__*/make((self, that) => self === that);\n/**\n * `Semigroup` that returns last minimum of elements.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const min = O => make((self, that) => O.compare(self, that) === -1 ? self : that);\n/**\n * `Semigroup` that returns last maximum of elements.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const max = O => make((self, that) => O.compare(self, that) === 1 ? self : that);\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const constant = a => make(() => a, () => a);\n/**\n * The dual of a `Semigroup`, obtained by flipping the arguments of `combine`.\n *\n * @since 1.0.0\n */\nexport const reverse = S => make((self, that) => S.combine(that, self), (self, collection) => {\n  const reversed = Array.from(collection).reverse();\n  return reversed.length > 0 ? S.combine(S.combineMany(reversed[0], reversed.slice(1)), self) : self;\n});\n/**\n * @since 1.0.0\n */\nexport const intercalate = /*#__PURE__*/dual(2, (S, separator) => make((self, that) => S.combineMany(self, [separator, that])));\n/**\n * Always return the first argument.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const first = () => make(a => a, a => a);\n/**\n * Always return the last argument.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const last = () => make((_, second) => second, (self, collection) => {\n  let a = self;\n  // eslint-disable-next-line no-empty\n  for (a of collection) {}\n  return a;\n});\n/**\n * @since 1.0.0\n */\nexport const imap = /*#__PURE__*/dual(3, (S, to, from) => make((self, that) => to(S.combine(from(self), from(that))), (self, collection) => to(S.combineMany(from(self), map(from)(collection)))));\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Invariant = {\n  imap\n};\nconst product = (self, that) => make(([xa, xb], [ya, yb]) => [self.combine(xa, ya), that.combine(xb, yb)]);\nconst productAll = collection => {\n  return make((x, y) => {\n    const len = Math.min(x.length, y.length);\n    const out = [];\n    let collectionLength = 0;\n    for (const s of collection) {\n      if (collectionLength >= len) {\n        break;\n      }\n      out.push(s.combine(x[collectionLength], y[collectionLength]));\n      collectionLength++;\n    }\n    return out;\n  });\n};\nconst productMany = (self, collection) => {\n  const semigroup = productAll(collection);\n  return make((x, y) => [self.combine(x[0], y[0]), ...semigroup.combine(x.slice(1), y.slice(1))]);\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const SemiProduct = {\n  imap,\n  product,\n  productMany\n};\nconst of = constant;\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Product = {\n  of,\n  imap,\n  product,\n  productMany,\n  productAll\n};\n/**\n * Similar to `Promise.all` but operates on `Semigroup`s.\n *\n * ```\n * [Semigroup<A>, Semigroup<B>, ...] -> Semigroup<[A, B, ...]>\n * ```\n *\n * This function creates and returns a new `Semigroup` for a tuple of values based on the given `Semigroup`s for each element in the tuple.\n * The returned `Semigroup` combines two tuples of the same type by applying the corresponding `Semigroup` passed as arguments to each element in the tuple.\n *\n * It is useful when you need to combine two tuples of the same type and you have a specific way of combining each element of the tuple.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const tuple = /*#__PURE__*/product_.tuple(Product);\n/**\n * Given a type `A`, this function creates and returns a `Semigroup` for `ReadonlyArray<A>`.\n * The returned `Semigroup` combines two arrays by concatenating them.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const array = () => make((self, that) => self.concat(that));\n/**\n * This function creates and returns a new `Semigroup` for a struct of values based on the given `Semigroup`s for each property in the struct.\n * The returned `Semigroup` combines two structs of the same type by applying the corresponding `Semigroup` passed as arguments to each property in the struct.\n *\n * It is useful when you need to combine two structs of the same type and you have a specific way of combining each property of the struct.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const struct = /*#__PURE__*/product_.struct(Product);\n//# sourceMappingURL=Semigroup.mjs.map","/** @internal */\nexport function concat(that) {\n  return self => {\n    return {\n      [Symbol.iterator]() {\n        const iterA = self[Symbol.iterator]();\n        let doneA = false;\n        let iterB;\n        return {\n          next() {\n            if (!doneA) {\n              const r = iterA.next();\n              if (r.done) {\n                doneA = true;\n                iterB = that[Symbol.iterator]();\n                return iterB.next();\n              }\n              return r;\n            }\n            return iterB.next();\n          }\n        };\n      }\n    };\n  };\n}\nexport function reduce(b, f) {\n  return function (iterable) {\n    if (Array.isArray(iterable)) {\n      return iterable.reduce(f, b);\n    }\n    let result = b;\n    for (const n of iterable) {\n      result = f(result, n);\n    }\n    return result;\n  };\n}\nexport function map(f) {\n  return function (iterable) {\n    if (Array.isArray(iterable)) {\n      return iterable.map(f);\n    }\n    return function* () {\n      for (const n of iterable) {\n        yield f(n);\n      }\n    }();\n  };\n}\n//# sourceMappingURL=Iterable.mjs.map","import * as semigroup from \"@effect/data/typeclass/Semigroup\";\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const fromSemigroup = (S, empty) => ({\n  combine: S.combine,\n  combineMany: S.combineMany,\n  empty,\n  combineAll: collection => S.combineMany(empty, collection)\n});\n/**\n * Get a monoid where `combine` will return the minimum, based on the provided bounded order.\n *\n * The `empty` value is the `maxBound` value.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const min = B => fromSemigroup(semigroup.min(B), B.maxBound);\n/**\n * Get a monoid where `combine` will return the maximum, based on the provided bounded order.\n *\n * The `empty` value is the `minimum` value.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const max = B => fromSemigroup(semigroup.max(B), B.minBound);\n/**\n * The dual of a `Monoid`, obtained by swapping the arguments of `combine`.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const reverse = M => fromSemigroup(semigroup.reverse(M), M.empty);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const string = /*#__PURE__*/fromSemigroup(semigroup.string, \"\");\n/**\n * `number` monoid under addition.\n *\n * The `empty` value is `0`.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const numberSum = /*#__PURE__*/fromSemigroup(semigroup.numberSum, 0);\n/**\n * `number` monoid under multiplication.\n *\n * The `empty` value is `1`.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const numberMultiply = /*#__PURE__*/fromSemigroup(semigroup.numberMultiply, 1);\n/**\n * `number` monoid under addition.\n *\n * The `bigint` value is `0n`.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const bigintSum = /*#__PURE__*/fromSemigroup(semigroup.bigintSum, 0n);\n/**\n * `bigint` monoid under multiplication.\n *\n * The `empty` value is `1n`.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const bigintMultiply = /*#__PURE__*/fromSemigroup(semigroup.bigintMultiply, 1n);\n/**\n * `boolean` monoid under conjunction.\n *\n * The `empty` value is `true`.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const booleanEvery = /*#__PURE__*/fromSemigroup(semigroup.booleanEvery, true);\n/**\n * `boolean` monoid under disjunction.\n *\n * The `empty` value is `false`.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const booleanSome = /*#__PURE__*/fromSemigroup(semigroup.booleanSome, false);\n/**\n * `boolean` monoid under exclusive disjunction.\n *\n * The `empty` value is `false`.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const booleanXor = /*#__PURE__*/fromSemigroup(semigroup.booleanXor, false);\n/**\n * `boolean` monoid under equivalence.\n *\n * The `empty` value is `true`.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const booleanEqv = /*#__PURE__*/fromSemigroup(semigroup.booleanEqv, true);\n/**\n * Similar to `Promise.all` but operates on `Monoid`s.\n *\n * ```\n * [Monoid<A>, Monoid<B>, ...] -> Monoid<[A, B, ...]>\n * ```\n *\n * This function creates and returns a new `Monoid` for a tuple of values based on the given `Monoid`s for each element in the tuple.\n * The returned `Monoid` combines two tuples of the same type by applying the corresponding `Monoid` passed as arguments to each element in the tuple.\n *\n * The `empty` value of the returned `Monoid` is the tuple of `empty` values of the input `Monoid`s.\n *\n * It is useful when you need to combine two tuples of the same type and you have a specific way of combining each element of the tuple.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const tuple = (...elements) => {\n  const empty = elements.map(m => m.empty);\n  return fromSemigroup(semigroup.tuple(...elements), empty);\n};\n/**\n * Given a type `A`, this function creates and returns a `Semigroup` for `ReadonlyArray<A>`.\n *\n * The `empty` value is the empty array.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const array = () => fromSemigroup(semigroup.array(), []);\n/**\n * This function creates and returns a new `Monoid` for a struct of values based on the given `Monoid`s for each property in the struct.\n * The returned `Monoid` combines two structs of the same type by applying the corresponding `Monoid` passed as arguments to each property in the struct.\n *\n * The `empty` value of the returned `Monoid` is a struct where each property is the `empty` value of the corresponding `Monoid` in the input `monoids` object.\n *\n * It is useful when you need to combine two structs of the same type and you have a specific way of combining each property of the struct.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const struct = fields => {\n  const empty = {};\n  for (const k in fields) {\n    if (Object.prototype.hasOwnProperty.call(fields, k)) {\n      empty[k] = fields[k].empty;\n    }\n  }\n  return fromSemigroup(semigroup.struct(fields), empty);\n};\n//# sourceMappingURL=Monoid.mjs.map","/**\n * This module provides utility functions and type class instances for working with the `number` type in TypeScript.\n * It includes functions for basic arithmetic operations, as well as type class instances for\n * `Equivalence`, `Order`, `Semigroup`, and `Monoid`.\n *\n * @since 1.0.0\n */\nimport { dual } from \"@effect/data/Function\";\nimport * as predicate from \"@effect/data/Predicate\";\nimport * as bounded from \"@effect/data/typeclass/Bounded\";\nimport * as equivalence from \"@effect/data/typeclass/Equivalence\";\nimport * as monoid from \"@effect/data/typeclass/Monoid\";\nimport * as order from \"@effect/data/typeclass/Order\";\nimport * as semigroup from \"@effect/data/typeclass/Semigroup\";\n/**\n * Tests if a value is a `number`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNumber } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(isNumber(2), true)\n * assert.deepStrictEqual(isNumber(\"2\"), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexport const isNumber = predicate.isNumber;\n/**\n * Provides an addition operation on `number`s.\n *\n * @param self - The first operand.\n * @param that - The second operand.\n *\n * @example\n * import { sum } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(sum(2, 3), 5)\n *\n * @category math\n * @since 1.0.0\n */\nexport const sum = /*#__PURE__*/dual(2, semigroup.numberSum.combine);\n/**\n * Provides a multiplication operation on `number`s.\n *\n * @param self - The first operand.\n * @param that - The second operand.\n *\n * @example\n * import { multiply } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(multiply(2, 3), 6)\n *\n * @category math\n * @since 1.0.0\n */\nexport const multiply = /*#__PURE__*/dual(2, semigroup.numberMultiply.combine);\n/**\n * Provides a subtraction operation on `number`s.\n *\n * @param self - The first operand.\n * @param that - The second operand.\n *\n * @example\n * import { subtract } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(subtract(2, 3), -1)\n *\n * @category math\n * @since 1.0.0\n */\nexport const subtract = /*#__PURE__*/dual(2, (self, that) => self - that);\n/**\n * Provides a division operation on `number`s.\n *\n * @param self - The dividend operand.\n * @param that - The divisor operand.\n *\n * @example\n * import { divide } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(divide(6, 3), 2)\n *\n * @category math\n * @since 1.0.0\n */\nexport const divide = /*#__PURE__*/dual(2, (self, that) => self / that);\n/**\n * Returns the result of adding `1` to a given number.\n *\n * @param n - A `number` to be incremented.\n *\n * @example\n * import { increment } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(increment(2), 3)\n *\n * @category math\n * @since 1.0.0\n */\nexport const increment = n => n + 1;\n/**\n * Decrements a number by `1`.\n *\n * @param n - A `number` to be decremented.\n *\n * @example\n * import { decrement } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(decrement(3), 2)\n *\n * @category math\n * @since 1.0.0\n */\nexport const decrement = n => n - 1;\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Equivalence = equivalence.number;\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Order = order.number;\n/**\n * Returns `true` if the first argument is less than the second, otherwise `false`.\n *\n * @param self - The first argument.\n * @param that - The second argument.\n *\n * @example\n * import { lessThan } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(lessThan(2, 3), true)\n * assert.deepStrictEqual(lessThan(3, 3), false)\n * assert.deepStrictEqual(lessThan(4, 3), false)\n *\n * @category predicates\n * @since 1.0.0\n */\nexport const lessThan = /*#__PURE__*/order.lessThan(Order);\n/**\n * Returns a function that checks if a given `number` is less than or equal to the provided one.\n *\n * @param self - The first `number` to compare with.\n * @param that - The second `number` to compare with.\n *\n * @example\n * import { lessThanOrEqualTo } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(lessThanOrEqualTo(2, 3), true)\n * assert.deepStrictEqual(lessThanOrEqualTo(3, 3), true)\n * assert.deepStrictEqual(lessThanOrEqualTo(4, 3), false)\n *\n * @category predicates\n * @since 1.0.0\n */\nexport const lessThanOrEqualTo = /*#__PURE__*/order.lessThanOrEqualTo(Order);\n/**\n * Returns `true` if the first argument is greater than the second, otherwise `false`.\n *\n * @param self - The first argument.\n * @param that - The second argument.\n *\n * @example\n * import { greaterThan } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(greaterThan(2, 3), false)\n * assert.deepStrictEqual(greaterThan(3, 3), false)\n * assert.deepStrictEqual(greaterThan(4, 3), true)\n *\n * @category predicates\n * @since 1.0.0\n */\nexport const greaterThan = /*#__PURE__*/order.greaterThan(Order);\n/**\n * Returns a function that checks if a given `number` is greater than or equal to the provided one.\n *\n * @param self - The first `number` to compare with.\n * @param that - The second `number` to compare with.\n *\n * @example\n * import { greaterThanOrEqualTo } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(greaterThanOrEqualTo(2, 3), false)\n * assert.deepStrictEqual(greaterThanOrEqualTo(3, 3), true)\n * assert.deepStrictEqual(greaterThanOrEqualTo(4, 3), true)\n *\n * @category predicates\n * @since 1.0.0\n */\nexport const greaterThanOrEqualTo = /*#__PURE__*/order.greaterThanOrEqualTo(Order);\n/**\n * Checks if a `number` is between a `minimum` and `maximum` value (inclusive).\n *\n * @param self - The `number` to check.\n * @param minimum - The `minimum` value to check.\n * @param maximum - The `maximum` value to check.\n *\n * @example\n * import { between } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(between(0, 5)(3), true)\n * assert.deepStrictEqual(between(0, 5)(-1), false)\n * assert.deepStrictEqual(between(0, 5)(6), false)\n *\n * @category predicates\n * @since 1.0.0\n */\nexport const between = /*#__PURE__*/order.between(Order);\n/**\n * Restricts the given `number` to be within the range specified by the `minimum` and `maximum` values.\n *\n * - If the `number` is less than the `minimum` value, the function returns the `minimum` value.\n * - If the `number` is greater than the `maximum` value, the function returns the `maximum` value.\n * - Otherwise, it returns the original `number`.\n *\n * @param self - The `number` to be clamped.\n * @param minimum - The lower end of the range.\n * @param maximum - The upper end of the range.\n *\n * @example\n * import { clamp } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(clamp(0, 5)(3), 3)\n * assert.deepStrictEqual(clamp(0, 5)(-1), 0)\n * assert.deepStrictEqual(clamp(0, 5)(6), 5)\n *\n * @since 1.0.0\n */\nexport const clamp = /*#__PURE__*/order.clamp(Order);\n/**\n * Returns the minimum between two `number`s.\n *\n * @param self - The first `number`.\n * @param that - The second `number`.\n *\n * @example\n * import { min } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(min(2, 3), 2)\n *\n * @since 1.0.0\n */\nexport const min = /*#__PURE__*/order.min(Order);\n/**\n * Returns the maximum between two `number`s.\n *\n * @param self - The first `number`.\n * @param that - The second `number`.\n *\n * @example\n * import { max } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(max(2, 3), 3)\n *\n * @since 1.0.0\n */\nexport const max = /*#__PURE__*/order.max(Order);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Bounded = bounded.number;\n/**\n * `number` semigroup under addition.\n *\n * @example\n * import { SemigroupSum } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(SemigroupSum.combine(2, 3), 5)\n *\n * @category instances\n * @since 1.0.0\n */\nexport const SemigroupSum = semigroup.numberSum;\n/**\n * `number` semigroup under multiplication.\n *\n * @example\n * import { SemigroupMultiply } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(SemigroupMultiply.combine(2, 3), 6)\n *\n * @category instances\n * @since 1.0.0\n */\nexport const SemigroupMultiply = semigroup.numberMultiply;\n/**\n * A `Semigroup` that uses the minimum between two values.\n *\n * @example\n * import { SemigroupMin } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(SemigroupMin.combine(2, 3), 2)\n *\n * @category instances\n * @since 1.0.0\n */\nexport const SemigroupMin = /*#__PURE__*/semigroup.min(Order);\n/**\n * A `Semigroup` that uses the maximum between two values.\n *\n * @example\n * import { SemigroupMax } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(SemigroupMax.combine(2, 3), 3)\n *\n * @category instances\n * @since 1.0.0\n */\nexport const SemigroupMax = /*#__PURE__*/semigroup.max(Order);\n/**\n * `number` monoid under addition.\n *\n * The `empty` value is `0`.\n *\n * @example\n * import { MonoidSum } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(MonoidSum.combine(2, 3), 5)\n * assert.deepStrictEqual(MonoidSum.combine(2, MonoidSum.empty), 2)\n *\n * @category instances\n * @since 1.0.0\n */\nexport const MonoidSum = monoid.numberSum;\n/**\n * `number` monoid under multiplication.\n *\n * The `empty` value is `1`.\n *\n * @example\n * import { MonoidMultiply } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(MonoidMultiply.combine(2, 3), 6)\n * assert.deepStrictEqual(MonoidMultiply.combine(2, MonoidMultiply.empty), 2)\n *\n * @category instances\n * @since 1.0.0\n */\nexport const MonoidMultiply = monoid.numberMultiply;\n/**\n * A `Monoid` that uses the minimum between two values.\n *\n * The `empty` value is `-Infinity`.\n *\n * @example\n * import { MonoidMin } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(MonoidMin.combine(2, 3), 2)\n * assert.deepStrictEqual(MonoidMin.combine(2, MonoidMin.empty), 2)\n *\n * @category instances\n * @since 1.0.0\n */\nexport const MonoidMin = /*#__PURE__*/bounded.min(Bounded);\n/**\n * A `Monoid` that uses the maximum between two values.\n *\n * The `empty` value is `Infinity`.\n *\n * @example\n * import { MonoidMax } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(MonoidMax.combine(2, 3), 3)\n * assert.deepStrictEqual(MonoidMax.combine(2, MonoidMax.empty), 2)\n *\n * @category instances\n * @since 1.0.0\n */\nexport const MonoidMax = /*#__PURE__*/bounded.max(Bounded);\n/**\n * Determines the sign of a given `number`.\n *\n * @param n - The `number` to determine the sign of.\n *\n * @example\n * import { sign } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(sign(-5), -1)\n * assert.deepStrictEqual(sign(0), 0)\n * assert.deepStrictEqual(sign(5), 1)\n *\n * @category math\n * @since 1.0.0\n */\nexport const sign = n => Order.compare(n, 0);\n/**\n * Takes an `Iterable` of `number`s and returns their sum as a single `number`.\n *\n * @param collection - The collection of `number`s to sum.\n *\n * @example\n * import { sumAll } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(sumAll([2, 3, 4]), 9)\n *\n * @category math\n * @since 1.0.0\n */\nexport const sumAll = MonoidSum.combineAll;\n/**\n * Takes an `Iterable` of `number`s and returns their multiplication as a single `number`.\n *\n * @param collection - The collection of `number`s to multiply.\n *\n * @example\n * import { multiplyAll } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(multiplyAll([2, 3, 4]), 24)\n *\n * @category math\n * @since 1.0.0\n */\nexport const multiplyAll = MonoidMultiply.combineAll;\n/**\n * Returns the remainder left over when one operand is divided by a second operand.\n *\n * It always takes the sign of the dividend.\n *\n * @param self - The dividend.\n * @param divisor - The divisor.\n *\n * @example\n * import { remainder } from \"@effect/data/Number\"\n *\n * assert.deepStrictEqual(remainder(2, 2), 0)\n * assert.deepStrictEqual(remainder(3, 2), 1)\n * assert.deepStrictEqual(remainder(-4, 2), -0)\n *\n * @category math\n * @since 1.0.0\n */\nexport const remainder = /*#__PURE__*/dual(2, (self, divisor) => {\n  // https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\n  const selfDecCount = (self.toString().split(\".\")[1] || \"\").length;\n  const divisorDecCount = (divisor.toString().split(\".\")[1] || \"\").length;\n  const decCount = selfDecCount > divisorDecCount ? selfDecCount : divisorDecCount;\n  const selfInt = parseInt(self.toFixed(decCount).replace(\".\", \"\"));\n  const divisorInt = parseInt(divisor.toFixed(decCount).replace(\".\", \"\"));\n  return selfInt % divisorInt / Math.pow(10, decCount);\n});\n//# sourceMappingURL=Number.mjs.map","import * as Equal from \"@effect/data/Equal\";\nimport { constNull, constUndefined, dual } from \"@effect/data/Function\";\nimport * as Gen from \"@effect/data/Gen\";\nimport * as either from \"@effect/data/internal/Either\";\nimport * as option from \"@effect/data/internal/Option\";\nimport * as N from \"@effect/data/Number\";\nimport * as applicative from \"@effect/data/typeclass/Applicative\";\nimport * as chainable from \"@effect/data/typeclass/Chainable\";\nimport * as covariant from \"@effect/data/typeclass/Covariant\";\nimport * as equivalence from \"@effect/data/typeclass/Equivalence\";\nimport * as filterable from \"@effect/data/typeclass/Filterable\";\nimport * as flatMap_ from \"@effect/data/typeclass/FlatMap\";\nimport * as foldable from \"@effect/data/typeclass/Foldable\";\nimport * as invariant from \"@effect/data/typeclass/Invariant\";\nimport * as monoid from \"@effect/data/typeclass/Monoid\";\nimport * as of_ from \"@effect/data/typeclass/Of\";\nimport * as order from \"@effect/data/typeclass/Order\";\nimport * as product_ from \"@effect/data/typeclass/Product\";\nimport * as semiApplicative from \"@effect/data/typeclass/SemiApplicative\";\nimport * as semiCoproduct from \"@effect/data/typeclass/SemiCoproduct\";\nimport * as semigroup from \"@effect/data/typeclass/Semigroup\";\nimport * as semiProduct from \"@effect/data/typeclass/SemiProduct\";\nimport * as traversable from \"@effect/data/typeclass/Traversable\";\n/**\n * @category symbols\n * @since 1.0.0\n */\nexport const OptionTypeId = /*#__PURE__*/Symbol.for(\"@effect/data/Option\");\n/**\n * Creates a new `Option` that represents the absence of a value.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const none = () => option.none;\n/**\n * Creates a new `Option` that wraps the given value.\n *\n * @param value - The value to wrap.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const some = option.some;\n/**\n * Tests if a value is a `Option`.\n *\n * @param input - The value to check.\n *\n * @example\n * import { some, none, isOption } from '@effect/data/Option'\n *\n * assert.deepStrictEqual(isOption(some(1)), true)\n * assert.deepStrictEqual(isOption(none()), true)\n * assert.deepStrictEqual(isOption({}), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexport const isOption = input => typeof input === \"object\" && input != null && \"_tag\" in input && (input[\"_tag\"] === \"None\" || input[\"_tag\"] === \"Some\") && Equal.isEqual(input);\n/**\n * Determine if a `Option` is a `None`.\n *\n * @param self - The `Option` to check.\n *\n * @example\n * import { some, none, isNone } from '@effect/data/Option'\n *\n * assert.deepStrictEqual(isNone(some(1)), false)\n * assert.deepStrictEqual(isNone(none()), true)\n *\n * @category guards\n * @since 1.0.0\n */\nexport const isNone = option.isNone;\n/**\n * Determine if a `Option` is a `Some`.\n *\n * @param self - The `Option` to check.\n *\n * @example\n * import { some, none, isSome } from '@effect/data/Option'\n *\n * assert.deepStrictEqual(isSome(some(1)), true)\n * assert.deepStrictEqual(isSome(none()), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexport const isSome = option.isSome;\n/**\n * Matches the given `Option` and returns either the provided `onNone` value or the result of the provided `onSome`\n * function when passed the `Option`'s value.\n *\n * @param self - The `Option` to match\n * @param onNone - The value to be returned if the `Option` is `None`\n * @param onSome - The function to be called if the `Option` is `Some`, it will be passed the `Option`'s value and its result will be returned\n *\n * @example\n * import { some, none, match } from '@effect/data/Option'\n * import { pipe } from \"@effect/data/Function\"\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     some(1),\n *     match(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a some containing 1'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     none(),\n *     match(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a none'\n * )\n *\n * @category pattern matching\n * @since 1.0.0\n */\nexport const match = /*#__PURE__*/dual(3, (self, onNone, onSome) => isNone(self) ? onNone() : onSome(self.value));\n/**\n * Returns a type guard from a `Option` returning function.\n * This function ensures that a type guard definition is type-safe.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * const parsePositive = (n: number): O.Option<number> =>\n *   n > 0 ? O.some(n) : O.none()\n *\n * const isPositive = O.toRefinement(parsePositive)\n *\n * assert.deepStrictEqual(isPositive(1), true)\n * assert.deepStrictEqual(isPositive(-1), false)\n *\n * @category conversions\n * @since 1.0.0\n */\nexport const toRefinement = f => a => isSome(f(a));\n/**\n * Converts an `Iterable` of values into an `Option`. Returns the first value of the `Iterable` wrapped in a `Some`\n * if the `Iterable` is not empty, otherwise returns `None`.\n *\n * @param collection - The `Iterable` to be converted to an `Option`.\n *\n * @example\n * import { fromIterable, some, none } from '@effect/data/Option'\n *\n * assert.deepStrictEqual(fromIterable([1, 2, 3]), some(1))\n * assert.deepStrictEqual(fromIterable([]), none())\n *\n * @category conversions\n * @since 1.0.0\n */\nexport const fromIterable = collection => {\n  for (const a of collection) {\n    return some(a);\n  }\n  return none();\n};\n/**\n * Converts a `Either` to an `Option` discarding the error.\n *\n * @param self - The `Either` to convert to an `Option`.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n * import * as E from \"@effect/data/Either\"\n *\n * assert.deepStrictEqual(O.fromEither(E.right(1)), O.some(1))\n * assert.deepStrictEqual(O.fromEither(E.left('error message')), O.none())\n *\n * @category conversions\n * @since 1.0.0\n */\nexport const fromEither = either.getRight;\n/**\n * Converts a `Either` to an `Option` discarding the error.\n *\n * Alias of {@link fromEither}.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n * import * as E from \"@effect/data/Either\"\n *\n * assert.deepStrictEqual(O.getRight(E.right('ok')), O.some('ok'))\n * assert.deepStrictEqual(O.getRight(E.left('err')), O.none())\n *\n * @category conversions\n * @since 1.0.0\n */\nexport const getRight = fromEither;\n/**\n * Converts a `Either` to an `Option` discarding the value.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n * import * as E from \"@effect/data/Either\"\n *\n * assert.deepStrictEqual(O.getLeft(E.right(\"ok\")), O.none())\n * assert.deepStrictEqual(O.getLeft(E.left(\"error\")), O.some(\"error\"))\n *\n * @category conversions\n * @since 1.0.0\n */\nexport const getLeft = either.getLeft;\n/**\n * Converts an `Option` to an `Either`, allowing you to provide a value to be used in the case of a `None`.\n *\n * @param self - the `Option` to convert.\n * @param onNone - a function that produces an error value when the `Option` is `None`.\n *\n * @example\n * import { pipe } from \"@effect/data/Function\"\n * import * as O from \"@effect/data/Option\"\n * import * as E from \"@effect/data/Either\"\n *\n * const onNone = () => 'error'\n * assert.deepStrictEqual(pipe(O.some(1), O.toEither(onNone)), E.right(1))\n * assert.deepStrictEqual(pipe(O.none(), O.toEither(onNone)), E.left('error'))\n *\n * @category conversions\n * @since 1.0.0\n */\nexport const toEither = either.fromOption;\n/**\n * Returns the value of the `Option` if it is `Some`, otherwise returns `onNone`\n *\n * @param self - The `Option` to get the value of.\n * @param onNone - Function that returns the default value to return if the `Option` is `None`.\n *\n * @example\n * import { some, none, getOrElse } from '@effect/data/Option'\n * import { pipe } from \"@effect/data/Function\"\n *\n * assert.deepStrictEqual(pipe(some(1), getOrElse(() => 0)), 1)\n * assert.deepStrictEqual(pipe(none(), getOrElse(() => 0)), 0)\n *\n * @category getters\n * @since 1.0.0\n */\nexport const getOrElse = /*#__PURE__*/dual(2, (self, onNone) => isNone(self) ? onNone() : self.value);\n/**\n * Returns the provided `Option` `that` if `self` is `None`, otherwise returns `self`.\n *\n * @param self - The first `Option` to be checked.\n * @param that - The `Option` to return if `self` is `None`.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n * import { pipe } from \"@effect/data/Function\"\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none(),\n *     O.orElse(() => O.none())\n *   ),\n *   O.none()\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some('a'),\n *     O.orElse(() => O.none())\n *   ),\n *   O.some('a')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none(),\n *     O.orElse(() => O.some('b'))\n *   ),\n *   O.some('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some('a'),\n *     O.orElse(() => O.some('b'))\n *   ),\n *   O.some('a')\n * )\n *\n * @category error handling\n * @since 1.0.0\n */\nexport const orElse = /*#__PURE__*/dual(2, (self, that) => isNone(self) ? that() : self);\n/**\n * Similar to `orElse`, but instead of returning a simple union, it returns an `Either` object,\n * which contains information about which of the two `Option`s has been chosen.\n *\n * This is useful when it's important to know whether the value was retrieved from the first `Option` or the second option.\n *\n * @param self - The first `Option` to be checked.\n * @param that - The second `Option` to be considered if the first `Option` is `None`.\n *\n * @category error handling\n * @since 1.0.0\n */\nexport const orElseEither = /*#__PURE__*/dual(2, (self, that) => isNone(self) ? map(that(), either.right) : map(self, either.left));\n/**\n * Given an `Iterable` collection of `Option`s, returns the first `Some` found in the collection.\n *\n * @param collection - An iterable collection of `Option` to be searched.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * assert.deepStrictEqual(O.firstSomeOf([O.none(), O.some(1), O.some(2)]), O.some(1))\n *\n * @category error handling\n * @since 1.0.0\n */\nexport const firstSomeOf = collection => {\n  let out = none();\n  for (out of collection) {\n    if (isSome(out)) {\n      return out;\n    }\n  }\n  return out;\n};\n/**\n * Similar to `Promise.all` but operates on `Option`s.\n *\n * ```\n * Iterable<Option<A>> -> Option<A[]>\n * ```\n *\n * Flattens a collection of `Option`s into a single `Option` that contains a list of all the `Some` values.\n * If there is a `None` value in the collection, it returns `None` as the result.\n *\n * @param collection - An iterable collection of `Option`s to flatten.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * assert.deepStrictEqual(O.all([O.some(1), O.some(2), O.some(3)]), O.some([1, 2, 3]))\n * assert.deepStrictEqual(O.all([O.some(1), O.none(), O.some(3)]), O.none())\n *\n * @category combining\n * @since 1.0.0\n */\nexport const all = collection => {\n  const out = [];\n  for (const o of collection) {\n    if (isNone(o)) {\n      return none();\n    }\n    out.push(o.value);\n  }\n  return some(out);\n};\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`.\n *\n * @param nullableValue - The nullable value to be converted to an `Option`.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * assert.deepStrictEqual(O.fromNullable(undefined), O.none())\n * assert.deepStrictEqual(O.fromNullable(null), O.none())\n * assert.deepStrictEqual(O.fromNullable(1), O.some(1))\n *\n * @category conversions\n * @since 1.0.0\n */\nexport const fromNullable = nullableValue => nullableValue == null ? none() : some(nullableValue);\n/**\n * This API is useful for lifting a function that returns `null` or `undefined` into the `Option` context.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * const parse = (s: string): number | undefined => {\n *   const n = parseFloat(s)\n *   return isNaN(n) ? undefined : n\n * }\n *\n * const parseOption = O.liftNullable(parse)\n *\n * assert.deepStrictEqual(parseOption('1'), O.some(1))\n * assert.deepStrictEqual(parseOption('not a number'), O.none())\n *\n * @category conversions\n * @since 1.0.0\n */\nexport const liftNullable = f => (...a) => fromNullable(f(...a));\n/**\n * Returns the value of the `Option` if it is a `Some`, otherwise returns `null`.\n *\n * @param self - The `Option` to extract the value from.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * assert.deepStrictEqual(O.getOrNull(O.some(1)), 1)\n * assert.deepStrictEqual(O.getOrNull(O.none()), null)\n *\n * @category getters\n * @since 1.0.0\n */\nexport const getOrNull = /*#__PURE__*/getOrElse(constNull);\n/**\n * Returns the value of the `Option` if it is a `Some`, otherwise returns `undefined`.\n *\n * @param self - The `Option` to extract the value from.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * assert.deepStrictEqual(O.getOrUndefined(O.some(1)), 1)\n * assert.deepStrictEqual(O.getOrUndefined(O.none()), undefined)\n *\n * @category getters\n * @since 1.0.0\n */\nexport const getOrUndefined = /*#__PURE__*/getOrElse(constUndefined);\n/**\n * A utility function that lifts a function that throws exceptions into a function that returns an `Option`.\n *\n * This function is useful for any function that might throw an exception, allowing the developer to handle\n * the exception in a more functional way.\n *\n * @param f - the function that can throw exceptions.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * const parse = O.liftThrowable(JSON.parse)\n *\n * assert.deepStrictEqual(parse(\"1\"), O.some(1))\n * assert.deepStrictEqual(parse(\"\"), O.none())\n *\n * @category conversions\n * @since 1.0.0\n */\nexport const liftThrowable = f => (...a) => {\n  try {\n    return some(f(...a));\n  } catch (e) {\n    return none();\n  }\n};\n/**\n * Extracts the value of an `Option` or throws if the `Option` is `None`.\n *\n * If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.\n *\n * @param self - The `Option` to extract the value from.\n * @param onNone - A function that will be called if the `Option` is `None`. It returns the error to be thrown.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * assert.deepStrictEqual(\n *   O.getOrThrowWith(O.some(1), () => new Error('Unexpected None')),\n *   1\n * )\n * assert.throws(() => O.getOrThrowWith(O.none(), () => new Error('Unexpected None')))\n *\n * @category conversions\n * @since 1.0.0\n */\nexport const getOrThrowWith = /*#__PURE__*/dual(2, (self, onNone) => {\n  if (isSome(self)) {\n    return self.value;\n  }\n  throw onNone();\n});\n/**\n * Extracts the value of an `Option` or throws if the `Option` is `None`.\n *\n * The thrown error is a default error. To configure the error thrown, see  {@link getOrThrowWith}.\n *\n * @param self - The `Option` to extract the value from.\n * @throws `Error(\"getOrThrow called on a None\")`\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * assert.deepStrictEqual(O.getOrThrow(O.some(1)), 1)\n * assert.throws(() => O.getOrThrow(O.none()))\n *\n * @category conversions\n * @since 1.0.0\n */\nexport const getOrThrow = /*#__PURE__*/getOrThrowWith(() => new Error(\"getOrThrow called on a None\"));\n/**\n * Maps the `Some` side of an `Option` value to a new `Option` value.\n *\n * @param self - An `Option` to map\n * @param f - The function to map over the value of the `Option`\n *\n * @category transforming\n * @since 1.0.0\n */\nexport const map = /*#__PURE__*/dual(2, (self, f) => isNone(self) ? none() : some(f(self.value)));\nconst imap = /*#__PURE__*/covariant.imap(map);\n/**\n * @since 1.0.0\n */\nexport const Covariant = {\n  imap,\n  map\n};\n/**\n * @since 1.0.0\n */\nexport const Invariant = {\n  imap\n};\n/**\n * @category transforming\n * @since 1.0.0\n */\nexport const flap = /*#__PURE__*/covariant.flap(Covariant);\n/**\n * Maps the `Some` value of this `Option` to the specified constant value.\n *\n * @category transforming\n * @since 1.0.0\n */\nexport const as = /*#__PURE__*/covariant.as(Covariant);\n/**\n * Maps the `Some` value of this `Option` to the `void` constant value.\n *\n * This is useful when the value of the `Option` is not needed, but the presence or absence of the value is important.\n *\n * @category transforming\n * @since 1.0.0\n */\nexport const asUnit = /*#__PURE__*/covariant.asUnit(Covariant);\nconst of = some;\nconst Of = {\n  of\n};\n/**\n * @since 1.0.0\n */\nexport const unit = /*#__PURE__*/of_.unit(Of);\n/**\n * @since 1.0.0\n */\nexport const Pointed = {\n  of,\n  imap,\n  map\n};\n/**\n * Applies a function to the value of an `Option` and flattens the result, if the input is `Some`.\n *\n * @category transforming\n * @since 1.0.0\n */\nexport const flatMap = /*#__PURE__*/dual(2, (self, f) => isNone(self) ? none() : f(self.value));\n/**\n * Applies a provided function that returns an `Either` to the contents of an `Option`, flattening the result into another `Option`.\n *\n * @param self - The `Option` to apply the function to.\n * @param f - The function to be applied to the contents of the `Option`.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n * import * as E from \"@effect/data/Either\"\n * import { pipe } from \"@effect/data/Function\"\n *\n * const f = (n: number) => (n > 2 ? E.left('Too big') : E.right(n + 1))\n *\n * assert.deepStrictEqual(pipe(O.some(1), O.flatMapEither(f)), O.some(2))\n * assert.deepStrictEqual(pipe(O.some(3), O.flatMapEither(f)), O.none())\n *\n * @category transforming\n * @since 1.0.0\n */\nexport const flatMapEither = /*#__PURE__*/dual(2, (self, f) => flatMap(self, liftEither(f)));\n/**\n * This is `flatMap` + `fromNullable`, useful when working with optional values.\n *\n * @example\n * import { some, none, flatMapNullable } from '@effect/data/Option'\n * import { pipe } from \"@effect/data/Function\"\n *\n * interface Employee {\n *   company?: {\n *     address?: {\n *       street?: {\n *         name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     some(employee1),\n *     flatMapNullable(employee => employee.company?.address?.street?.name),\n *   ),\n *   some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     some(employee2),\n *     flatMapNullable(employee => employee.company?.address?.street?.name),\n *   ),\n *   none()\n * )\n *\n * @category transforming\n * @since 1.0.0\n */\nexport const flatMapNullable = /*#__PURE__*/dual(2, (self, f) => isNone(self) ? none() : fromNullable(f(self.value)));\n/**\n * @since 1.0.0\n */\nexport const FlatMap = {\n  flatMap\n};\n/**\n * @category transforming\n * @since 1.0.0\n */\nexport const flatten = /*#__PURE__*/flatMap_.flatten(FlatMap);\n/**\n * @category transforming\n * @since 1.0.0\n */\nexport const zipRight = /*#__PURE__*/flatMap_.zipRight(FlatMap);\n/**\n * @category transforming\n * @since 1.0.0\n */\nexport const composeK = /*#__PURE__*/flatMap_.composeK(FlatMap);\n/**\n * @since 1.0.0\n */\nexport const Chainable = {\n  imap,\n  map,\n  flatMap\n};\n/**\n * Sequences the specified `that` `Option` but ignores its value.\n *\n * It is useful when we want to chain multiple operations, but only care about the result of `self`.\n *\n * @param that - The `Option` that will be ignored in the chain and discarded\n * @param self - The `Option` we care about\n *\n * @category transforming\n * @since 1.0.0\n */\nexport const zipLeft = /*#__PURE__*/chainable.zipLeft(Chainable);\n/**\n * Applies the provided function `f` to the value of the `Option` if it is `Some` and returns the original `Option`\n * unless `f` returns `None`, in which case it returns `None`.\n *\n * This function is useful for performing additional computations on the value of the input `Option` without affecting its value.\n *\n * @param f - Function to apply to the value of the `Option` if it is `Some`\n * @param self - The `Option` to apply the function to\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * const getInteger = (n: number) => Number.isInteger(n) ? O.some(n) : O.none()\n *\n * assert.deepStrictEqual(O.tap(O.none(), getInteger), O.none())\n * assert.deepStrictEqual(O.tap(O.some(1), getInteger), O.some(1))\n * assert.deepStrictEqual(O.tap(O.some(1.14), getInteger), O.none())\n *\n * @category transforming\n * @since 1.0.0\n */\nexport const tap = /*#__PURE__*/chainable.tap(Chainable);\n/**\n * Useful for debugging purposes, the `onSome` callback is called with the value of `self` if it is a `Some`.\n *\n * @param self - the `Option` to inspect\n * @param onSome - callback function that is called with the value of `self` if it is a `Some`\n *\n * @category debugging\n * @since 1.0.0\n */\nexport const inspectSome = /*#__PURE__*/dual(2, (self, onSome) => {\n  if (isSome(self)) {\n    onSome(self.value);\n  }\n  return self;\n});\n/**\n * Useful for debugging purposes, the `onNone` callback is is called if `self` is a `None`.\n *\n * @param self - the `Option` to inspect\n * @param onNone - callback function that is is called if `self` is a `None`\n *\n * @category debugging\n * @since 1.0.0\n */\nexport const inspectNone = /*#__PURE__*/dual(2, (self, onNone) => {\n  if (isNone(self)) {\n    onNone();\n  }\n  return self;\n});\n/**\n * @since 1.0.0\n */\nexport const Monad = {\n  imap,\n  of,\n  map,\n  flatMap\n};\nconst product = (self, that) => isSome(self) && isSome(that) ? some([self.value, that.value]) : none();\nconst productMany = (self, collection) => {\n  if (isNone(self)) {\n    return none();\n  }\n  const out = [self.value];\n  for (const o of collection) {\n    if (isNone(o)) {\n      return none();\n    }\n    out.push(o.value);\n  }\n  return some(out);\n};\n/**\n * @since 1.0.0\n */\nexport const SemiProduct = {\n  imap,\n  product,\n  productMany\n};\n/**\n * @since 1.0.0\n */\nexport const Product = {\n  of,\n  imap,\n  product,\n  productMany,\n  productAll: all\n};\n/**\n * Similar to `Promise.all` but operates on `Option`s.\n *\n * ```\n * [Option<A>, Option<B>, ...] -> Option<[A, B, ...]>\n * ```\n *\n * Takes a tuple of `Option`s and returns an `Option` of a tuple of values.\n *\n * @param elements - the tuple of `Option`s to be sequenced.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * assert.deepStrictEqual(O.tuple(O.some(1), O.some(\"hello\")), O.some([1, \"hello\"]))\n * assert.deepStrictEqual(O.tuple(O.some(1), O.none()), O.none())\n *\n * @category combining\n * @since 1.0.0\n */\nexport const tuple = /*#__PURE__*/product_.tuple(Product);\n/**\n * Takes a struct of `Option`s and returns an `Option` of a struct of values.\n *\n * @param fields - the struct of `Option`s to be sequenced.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * assert.deepStrictEqual(O.struct({ a: O.some(1), b: O.some(\"hello\") }), O.some({ a: 1, b: \"hello\" }))\n * assert.deepStrictEqual(O.struct({ a: O.some(1), b: O.none() }), O.none())\n *\n * @category combining\n * @since 1.0.0\n */\nexport const struct = /*#__PURE__*/product_.struct(Product);\n/**\n * @since 1.0.0\n */\nexport const SemiApplicative = {\n  imap,\n  map,\n  product,\n  productMany\n};\n/**\n * Monoid that models the combination of values that may be absent, elements that are `None` are ignored\n * while elements that are `Some` are combined using the provided `Semigroup`.\n *\n * The `empty` value is `none()`.\n *\n * @param Semigroup - The `Semigroup` used to combine two values of type `A`.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n * import * as N from '@effect/data/Number'\n * import { pipe } from \"@effect/data/Function\"\n *\n * const M = O.getOptionalMonoid(N.SemigroupSum)\n *\n * assert.deepStrictEqual(M.combine(O.none(), O.none()), O.none())\n * assert.deepStrictEqual(M.combine(O.some(1), O.none()), O.some(1))\n * assert.deepStrictEqual(M.combine(O.none(), O.some(1)), O.some(1))\n * assert.deepStrictEqual(M.combine(O.some(1), O.some(2)), O.some(3))\n *\n * @since 1.0.0\n */\nexport const getOptionalMonoid = Semigroup => monoid.fromSemigroup(semigroup.make((self, that) => isNone(self) ? that : isNone(that) ? self : some(Semigroup.combine(self.value, that.value))), none());\n/**\n * Zips two `Option` values together using a provided function, returning a new `Option` of the result.\n *\n * @param self - The left-hand side of the zip operation\n * @param that - The right-hand side of the zip operation\n * @param f - The function used to combine the values of the two `Option`s\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * type Complex = [number, number]\n *\n * const complex = (real: number, imaginary: number): Complex => [real, imaginary]\n *\n * assert.deepStrictEqual(O.zipWith(O.none(), O.none(), complex), O.none())\n * assert.deepStrictEqual(O.zipWith(O.some(1), O.none(), complex), O.none())\n * assert.deepStrictEqual(O.zipWith(O.none(), O.some(1), complex), O.none())\n * assert.deepStrictEqual(O.zipWith(O.some(1), O.some(2), complex), O.some([1, 2]))\n *\n * assert.deepStrictEqual(O.zipWith(O.some(1), complex)(O.some(2)), O.some([2, 1]))\n *\n * @category combining\n * @since 1.0.0\n */\nexport const zipWith = /*#__PURE__*/semiApplicative.zipWith(SemiApplicative);\n/**\n * @category combining\n * @since 1.0.0\n */\nexport const ap = /*#__PURE__*/semiApplicative.ap(SemiApplicative);\n/**\n * Semigroup that models the combination of computations that can fail, if at least one element is `None`\n * then the resulting combination is `None`, otherwise if all elements are `Some` then the resulting combination\n * is the combination of the wrapped elements using the provided `Semigroup`.\n *\n * See also `getFailureMonoid` if you need a `Monoid` instead of a `Semigroup`.\n *\n * @category combining\n * @since 1.0.0\n */\nexport const getFailureSemigroup = /*#__PURE__*/semiApplicative.getSemigroup(SemiApplicative);\n/**\n * @since 1.0.0\n */\nexport const Applicative = {\n  imap,\n  of,\n  map,\n  product,\n  productMany,\n  productAll: all\n};\n/**\n * Monoid that models the combination of computations that can fail, if at least one element is `None`\n * then the resulting combination is `None`, otherwise if all elements are `Some` then the resulting combination\n * is the combination of the wrapped elements using the provided `Monoid`.\n *\n * The `empty` value is `some(M.empty)`.\n *\n * See also `getFailureSemigroup` if you need a `Semigroup` instead of a `Monoid`.\n *\n * @category combining\n * @since 1.0.0\n */\nexport const getFailureMonoid = /*#__PURE__*/applicative.getMonoid(Applicative);\nconst coproduct = (self, that) => isSome(self) ? self : that;\nconst coproductMany = (self, collection) => isSome(self) ? self : firstSomeOf(collection);\n/**\n * @since 1.0.0\n */\nexport const SemiCoproduct = {\n  imap,\n  coproduct,\n  coproductMany\n};\n/**\n * Semigroup returning the first `Some` value encountered.\n *\n * @category combining\n * @since 1.0.0\n */\nexport const getFirstSomeSemigroup = /*#__PURE__*/semiCoproduct.getSemigroup(SemiCoproduct);\n/**\n * @since 1.0.0\n */\nexport const Coproduct = {\n  imap,\n  coproduct,\n  coproductMany,\n  zero: none,\n  coproductAll: firstSomeOf\n};\n/**\n * @since 1.0.0\n */\nexport const SemiAlternative = {\n  map,\n  imap,\n  coproduct,\n  coproductMany\n};\n/**\n * @since 1.0.0\n */\nexport const Alternative = {\n  map,\n  imap,\n  coproduct,\n  coproductMany,\n  coproductAll: firstSomeOf,\n  zero: none\n};\n/**\n * Reduces an `Iterable` of `Option<A>` to a single value of type `B`, elements that are `None` are ignored.\n *\n * @param self - The Iterable of `Option<A>` to be reduced.\n * @param b - The initial value of the accumulator.\n * @param f - The reducing function that takes the current accumulator value and the unwrapped value of an `Option<A>`.\n *\n * @example\n * import { some, none, reduceCompact } from '@effect/data/Option'\n * import { pipe } from \"@effect/data/Function\"\n *\n * const iterable = [some(1), none(), some(2), none()]\n * assert.deepStrictEqual(pipe(iterable, reduceCompact(0, (b, a) => b + a)), 3)\n *\n * @category folding\n * @since 1.0.0\n */\nexport const reduceCompact = /*#__PURE__*/dual(3, (self, b, f) => {\n  let out = b;\n  for (const oa of self) {\n    if (isSome(oa)) {\n      out = f(out, oa.value);\n    }\n  }\n  return out;\n});\n/**\n * @since 1.0.0\n */\nexport const Foldable = {\n  reduce: /*#__PURE__*/dual(3, (self, b, f) => isNone(self) ? b : f(b, self.value))\n};\n/**\n * Transforms an `Option` into an `Array`.\n * If the input is `None`, an empty array is returned.\n * If the input is `Some`, the value is wrapped in an array.\n *\n * @param self - The `Option` to convert to an array.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * assert.deepStrictEqual(O.toArray(O.some(1)), [1])\n * assert.deepStrictEqual(O.toArray(O.none()), [])\n *\n * @category conversions\n * @since 1.0.0\n */\nexport const toArray = /*#__PURE__*/foldable.toArray(Foldable);\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const partitionMap = /*#__PURE__*/dual(2, (self, f) => {\n  if (isNone(self)) {\n    return [none(), none()];\n  }\n  const e = f(self.value);\n  return either.isLeft(e) ? [some(e.left), none()] : [none(), some(e.right)];\n});\n/**\n * Maps over the value of an `Option` and filters out `None`s.\n *\n * Useful when in addition to filtering you also want to change the type of the `Option`.\n *\n * @param self - The `Option` to map over.\n * @param f - A function to apply to the value of the `Option`.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * const evenNumber = (n: number) => n % 2 === 0 ? O.some(n) : O.none()\n *\n * assert.deepStrictEqual(O.filterMap(O.none(), evenNumber), O.none())\n * assert.deepStrictEqual(O.filterMap(O.some(3), evenNumber), O.none())\n * assert.deepStrictEqual(O.filterMap(O.some(2), evenNumber), O.some(2))\n *\n * @category filtering\n * @since 1.0.0\n */\nexport const filterMap = /*#__PURE__*/dual(2, (self, f) => isNone(self) ? none() : f(self.value));\n/**\n * @since 1.0.0\n */\nexport const Filterable = {\n  partitionMap,\n  filterMap\n};\n/**\n * Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`.\n *\n * If you need to change the type of the `Option` in addition to filtering, see `filterMap`.\n *\n * @param predicate - A predicate function to apply to the `Option` value.\n * @param fb - The `Option` to filter.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * // predicate\n * const isEven = (n: number) => n % 2 === 0\n *\n * assert.deepStrictEqual(O.filter(O.none(), isEven), O.none())\n * assert.deepStrictEqual(O.filter(O.some(3), isEven), O.none())\n * assert.deepStrictEqual(O.filter(O.some(2), isEven), O.some(2))\n *\n * // refinement\n * const isNumber = (v: unknown): v is number => typeof v === \"number\"\n *\n * assert.deepStrictEqual(O.filter(O.none(), isNumber), O.none())\n * assert.deepStrictEqual(O.filter(O.some('hello'), isNumber), O.none())\n * assert.deepStrictEqual(O.filter(O.some(2), isNumber), O.some(2))\n *\n * @category filtering\n * @since 1.0.0\n */\nexport const filter = /*#__PURE__*/filterable.filter(Filterable);\n/**\n * Applies an `Option` value to an effectful function that returns an `F` value.\n *\n * @param F - {@link applicative.Applicative} instance\n * @param self - The `Option` value.\n * @param f - An effectful function that returns an `F` value.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n * import * as E from \"@effect/data/Either\"\n *\n * const traverse = O.traverse(E.Applicative)\n * const f = (n: number) => n >= 0 ? E.right(1) : E.left(\"negative\")\n *\n * assert.deepStrictEqual(traverse(O.some(1), f), E.right(O.some(1)))\n * assert.deepStrictEqual(traverse(O.some(-1), f), E.left(\"negative\"))\n * assert.deepStrictEqual(traverse(O.none(), f), E.right(O.none()))\n *\n * @category combining\n * @since 1.0.0\n */\nexport const traverse = F => dual(2, (self, f) => isNone(self) ? F.of(none()) : F.map(f(self.value), some));\n/**\n * @since 1.0.0\n */\nexport const Traversable = {\n  traverse\n};\n/**\n * Combines an `Option` of an `F`-structure to an `F`-structure of an `Option` with the same inner type.\n *\n * @param F - {@link applicative.Applicative} instance\n * @param self - `Option` of Kind `F`\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n * import * as E from \"@effect/data/Either\"\n *\n * const sequence = O.sequence(E.Applicative)\n *\n * assert.deepStrictEqual(sequence(O.some(E.right(1))), E.right(O.some(1)))\n * assert.deepStrictEqual(sequence(O.some(E.left(\"error\"))), E.left(\"error\"))\n * assert.deepStrictEqual(sequence(O.none()), E.right(O.none()))\n *\n * @category combining\n * @since 1.0.0\n */\nexport const sequence = /*#__PURE__*/traversable.sequence(Traversable);\n/**\n * @category combining\n * @since 1.0.0\n */\nexport const traverseTap = /*#__PURE__*/traversable.traverseTap(Traversable);\n/**\n * @example\n * import { none, some, getEquivalence } from '@effect/data/Option'\n * import * as N from '@effect/data/Number'\n *\n * const isEquivalent = getEquivalence(N.Equivalence)\n * assert.deepStrictEqual(isEquivalent(none(), none()), true)\n * assert.deepStrictEqual(isEquivalent(none(), some(1)), false)\n * assert.deepStrictEqual(isEquivalent(some(1), none()), false)\n * assert.deepStrictEqual(isEquivalent(some(1), some(2)), false)\n * assert.deepStrictEqual(isEquivalent(some(1), some(1)), true)\n *\n * @category equivalence\n * @since 1.0.0\n */\nexport const getEquivalence = E => equivalence.make((x, y) => x === y || (isNone(x) ? isNone(y) : isNone(y) ? false : E(x.value, y.value)));\n/**\n * The `Order` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Order` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n * @example\n * import { none, some, getOrder } from '@effect/data/Option'\n * import * as N from '@effect/data/Number'\n * import { pipe } from \"@effect/data/Function\"\n *\n * const O = getOrder(N.Order)\n * assert.deepStrictEqual(O.compare(none(), none()), 0)\n * assert.deepStrictEqual(O.compare(none(), some(1)), -1)\n * assert.deepStrictEqual(O.compare(some(1), none()), 1)\n * assert.deepStrictEqual(O.compare(some(1), some(2)), -1)\n * assert.deepStrictEqual(O.compare(some(1), some(1)), 0)\n *\n * @category sorting\n * @since 1.0.0\n */\nexport const getOrder = O => order.make((self, that) => isSome(self) ? isSome(that) ? O.compare(self.value, that.value) : 1 : -1);\n/**\n * Lifts a binary function into `Option`.\n *\n * @param f - The function to lift.\n *\n * @category lifting\n * @since 1.0.0\n */\nexport const lift2 = /*#__PURE__*/semiApplicative.lift2(SemiApplicative);\n/**\n * Transforms a `Predicate` function into a `Some` of the input value if the predicate returns `true` or `None`\n * if the predicate returns `false`.\n *\n * @param predicate - A `Predicate` function that takes in a value of type `A` and returns a boolean.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * const getOption = O.liftPredicate((n: number) => n >= 0)\n *\n * assert.deepStrictEqual(getOption(-1), O.none())\n * assert.deepStrictEqual(getOption(1), O.some(1))\n *\n * @category lifting\n * @since 1.0.0\n */\nexport const liftPredicate = predicate => b => predicate(b) ? some(b) : none();\n/**\n * Lifts an `Either` function to an `Option` function.\n *\n * @param f - Any variadic function that returns an `Either`.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n * import * as E from \"@effect/data/Either\"\n *\n * const parse = (s: string) =>\n *   isNaN(+s) ? E.left(`Error: ${s} is not a number`) : E.right(+s)\n *\n * const parseNumber = O.liftEither(parse)\n *\n * assert.deepEqual(parseNumber('12'), O.some(12))\n * assert.deepEqual(parseNumber('not a number'), O.none())\n *\n * @category lifting\n * @since 1.0.0\n */\nexport const liftEither = f => (...a) => fromEither(f(...a));\n/**\n * Returns a function that checks if an `Option` contains a given value using a provided `Equivalence` instance.\n *\n * @param equivalent - An `Equivalence` instance to compare values of the `Option`.\n * @param self - The `Option` to apply the comparison to.\n * @param a - The value to compare against the `Option`.\n *\n * @example\n * import { some, none, contains } from '@effect/data/Option'\n * import { Equivalence } from '@effect/data/Number'\n * import { pipe } from \"@effect/data/Function\"\n *\n * assert.deepStrictEqual(pipe(some(2), contains(Equivalence)(2)), true)\n * assert.deepStrictEqual(pipe(some(1), contains(Equivalence)(2)), false)\n * assert.deepStrictEqual(pipe(none(), contains(Equivalence)(2)), false)\n *\n * @since 1.0.0\n */\nexport const contains = isEquivalent => dual(2, (self, a) => isNone(self) ? false : isEquivalent(self.value, a));\n/**\n * Check if a value in an `Option` type meets a certain predicate.\n *\n * @param self - The `Option` to check.\n * @param predicate - The condition to check.\n *\n * @example\n * import { some, none, exists } from '@effect/data/Option'\n * import { pipe } from \"@effect/data/Function\"\n *\n * const isEven = (n: number) => n % 2 === 0\n *\n * assert.deepStrictEqual(pipe(some(2), exists(isEven)), true)\n * assert.deepStrictEqual(pipe(some(1), exists(isEven)), false)\n * assert.deepStrictEqual(pipe(none(), exists(isEven)), false)\n *\n * @since 1.0.0\n */\nexport const exists = /*#__PURE__*/dual(2, (self, predicate) => isNone(self) ? false : predicate(self.value));\n// -------------------------------------------------------------------------------------\n// math\n// -------------------------------------------------------------------------------------\n/**\n * @category math\n * @since 1.0.0\n */\nexport const sum = /*#__PURE__*/lift2(N.sum);\n/**\n * @category math\n * @since 1.0.0\n */\nexport const multiply = /*#__PURE__*/lift2(N.multiply);\n/**\n * @category math\n * @since 1.0.0\n */\nexport const subtract = /*#__PURE__*/lift2(N.subtract);\n/**\n * @category math\n * @since 1.0.0\n */\nexport const divide = /*#__PURE__*/lift2(N.divide);\n/**\n * Sum all numbers in an iterable of `Option<number>` ignoring the `None` values.\n *\n * @param self - The iterable of `Option<number>` to be summed.\n *\n * @example\n * import { sumCompact, some, none } from '@effect/data/Option'\n *\n * const iterable = [some(2), none(), some(3), none()]\n * assert.deepStrictEqual(sumCompact(iterable), 5)\n *\n * @category math\n * @since 1.0.0\n */\nexport const sumCompact = self => {\n  let out = 0;\n  for (const oa of self) {\n    if (isSome(oa)) {\n      out += oa.value;\n    }\n  }\n  return out;\n};\n/**\n * Multiply all numbers in an iterable of `Option<number>` ignoring the `None` values.\n *\n * @param self - The iterable of `Option<number>` to be multiplied.\n *\n * @example\n * import { multiplyCompact, some, none } from '@effect/data/Option'\n *\n * const iterable = [some(2), none(), some(3), none()]\n * assert.deepStrictEqual(multiplyCompact(iterable), 6)\n *\n * @category math\n * @since 1.0.0\n */\nexport const multiplyCompact = self => {\n  let out = 1;\n  for (const oa of self) {\n    if (isSome(oa)) {\n      const a = oa.value;\n      if (a === 0) {\n        return 0;\n      }\n      out *= a;\n    }\n  }\n  return out;\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 1.0.0\n */\nexport const tupled = /*#__PURE__*/invariant.tupled(Invariant);\n/**\n * Appends an element to the end of a tuple wrapped in an `Option` type.\n *\n * @param self - The option of a tuple to which an element needs to be added.\n * @param that - The element which needs to be added to the tuple.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * assert.deepStrictEqual(O.appendElement(O.some([1, 2]), O.some(3)), O.some([1, 2, 3]))\n * assert.deepStrictEqual(O.appendElement(O.some([1, 2]), O.none()), O.none())\n *\n * @category do notation\n * @since 1.0.0\n */\nexport const appendElement = /*#__PURE__*/semiProduct.appendElement(SemiProduct);\n/**\n * @category do notation\n * @since 1.0.0\n */\nexport const bindTo = /*#__PURE__*/invariant.bindTo(Invariant);\nconst let_ = /*#__PURE__*/covariant.let(Covariant);\nexport {\n/**\n * @category do notation\n * @since 1.0.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 1.0.0\n */\nexport const letDiscard = /*#__PURE__*/covariant.letDiscard(Covariant);\n/**\n * @category do notation\n * @since 1.0.0\n */\nexport const bind = /*#__PURE__*/chainable.bind(Chainable);\n/**\n * @category do notation\n * @since 1.0.0\n */\nexport const Do = /*#__PURE__*/of_.Do(Of);\n/**\n * A variant of `bind` that sequentially ignores the scope.\n *\n * @category do notation\n * @since 1.0.0\n */\nexport const bindDiscard = /*#__PURE__*/semiProduct.bindDiscard(SemiProduct);\n/**\n * The `gen` API is a helper function that provides a generator interface for the `Option` monad instance.\n * It can be used to easily create complex `Option` computations in a readable and concise manner.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * assert.deepStrictEqual(\n *   O.gen(function*($) {\n *     const a = yield* $(O.some(1))\n *     const b = yield* $(O.some(2))\n *     return a + b\n *   }),\n *   O.some(3)\n * )\n *\n * @since 1.0.0\n * @category generators\n */\nexport const gen = /*#__PURE__*/Gen.singleShot(Monad)( /*#__PURE__*/Gen.adapter());\n//# sourceMappingURL=Option.mjs.map","/**\n * This module provides utility functions for working with tuples in TypeScript.\n *\n * @since 1.0.0\n */\nimport { dual } from \"@effect/data/Function\";\nimport * as bicovariant from \"@effect/data/typeclass/Bicovariant\";\nimport * as equivalence from \"@effect/data/typeclass/Equivalence\";\nimport * as monoid from \"@effect/data/typeclass/Monoid\";\nimport * as order from \"@effect/data/typeclass/Order\";\nimport * as semigroup from \"@effect/data/typeclass/Semigroup\";\n/**\n * Constructs a new tuple from the provided values.\n *\n * @param elements - The list of elements to create the tuple from.\n *\n * @example\n * import { tuple } from \"@effect/data/Tuple\"\n *\n * assert.deepStrictEqual(tuple(1, 'hello', true), [1, 'hello', true])\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const tuple = (...elements) => elements;\n/**\n * Return the first element of a tuple.\n *\n * @param self - A tuple of length `2`.\n *\n * @example\n * import { getFirst } from \"@effect/data/Tuple\"\n *\n * assert.deepStrictEqual(getFirst([\"hello\", 42]), \"hello\")\n *\n * @category getters\n * @since 1.0.0\n */\nexport const getFirst = self => self[0];\n/**\n * Return the second element of a tuple.\n *\n * @param self - A tuple of length `2`.\n *\n * @example\n * import { getSecond } from \"@effect/data/Tuple\"\n *\n * assert.deepStrictEqual(getSecond([\"hello\", 42]), 42)\n *\n * @category getters\n * @since 1.0.0\n */\nexport const getSecond = self => self[1];\n/**\n * Transforms both elements of a tuple using the given functions.\n *\n * @param self - A tuple of length `2`.\n * @param f - The function to transform the first element of the tuple.\n * @param g - The function to transform the second element of the tuple.\n *\n * @example\n * import { bimap } from \"@effect/data/Tuple\"\n *\n * assert.deepStrictEqual(\n *   bimap([\"hello\", 42], s => s.toUpperCase(), n => n.toString()),\n *   [\"HELLO\", \"42\"]\n * )\n *\n * @category mapping\n * @since 1.0.0\n */\nexport const bimap = /*#__PURE__*/dual(3, (self, f, g) => [f(self[0]), g(self[1])]);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Bicovariant = {\n  bimap\n};\n/**\n * Transforms the first component of a tuple using a given function.\n *\n * @param self - A tuple of length `2`.\n * @param f - The function to transform the first element of the tuple.\n *\n * @example\n * import { mapFirst } from \"@effect/data/Tuple\"\n *\n * assert.deepStrictEqual(\n *   mapFirst([\"hello\", 42], s => s.toUpperCase()),\n *   [\"HELLO\", 42]\n * )\n *\n * @category mapping\n * @since 1.0.0\n */\nexport const mapFirst = /*#__PURE__*/bicovariant.mapLeft(Bicovariant);\n/**\n * Transforms the second component of a tuple using a given function.\n *\n * @param self - A tuple of length `2`.\n * @param f - The function to transform the second element of the tuple.\n *\n * @example\n * import { mapSecond } from \"@effect/data/Tuple\"\n *\n * assert.deepStrictEqual(\n *   mapSecond([\"hello\", 42], n => n.toString()),\n *   [\"hello\", \"42\"]\n * )\n *\n * @category mapping\n * @since 1.0.0\n */\nexport const mapSecond = /*#__PURE__*/bicovariant.map(Bicovariant);\n/**\n * Swaps the two elements of a tuple.\n *\n * @param self - A tuple of length `2`.\n *\n * @example\n * import { swap } from \"@effect/data/Tuple\"\n *\n * assert.deepStrictEqual(swap([\"hello\", 42]), [42, \"hello\"])\n *\n * @since 1.0.0\n */\nexport const swap = self => [self[1], self[0]];\n/**\n * Given a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple\n * by applying each `Equivalence` to the corresponding element of the tuple.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const getEquivalence = equivalence.tuple;\n/**\n * This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.\n * The returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.\n * It is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element\n * of the tuple.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const getOrder = order.tuple;\n/**\n * This function creates and returns a new `Semigroup` for a tuple of values based on the given `Semigroup`s for each element in the tuple.\n * The returned `Semigroup` combines two tuples of the same type by applying the corresponding `Semigroup` passed as arguments to each element in the tuple.\n *\n * It is useful when you need to combine two tuples of the same type and you have a specific way of combining each element of the tuple.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const getSemigroup = semigroup.tuple;\n/**\n * This function creates and returns a new `Monoid` for a tuple of values based on the given `Monoid`s for each element in the tuple.\n * The returned `Monoid` combines two tuples of the same type by applying the corresponding `Monoid` passed as arguments to each element in the tuple.\n *\n * The `empty` value of the returned `Monoid` is the tuple of `empty` values of the input `Monoid`s.\n *\n * It is useful when you need to combine two tuples of the same type and you have a specific way of combining each element of the tuple.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const getMonoid = monoid.tuple;\n/**\n * Appends an element to the end of a tuple.\n *\n * @since 1.0.0\n */\nexport const appendElement = /*#__PURE__*/dual(2, (self, that) => [...self, that]);\n/*\n\n  TODO:\n\n  - at\n  - swap\n\n*/\n//# sourceMappingURL=Tuple.mjs.map","/**\n * @since 1.0.0\n */\nimport { dual, identity } from \"@effect/data/Function\";\n/**\n * Returns a default ternary `bimap` composition.\n *\n * @since 1.0.0\n */\nexport const bimapComposition = (CovariantF, BicovariantG) => (self, f, g) => CovariantF.map(self, BicovariantG.bimap(f, g));\n/**\n * Returns a default `mapLeft` implementation.\n *\n * @since 1.0.0\n */\nexport const mapLeft = F => dual(2, (self, f) => F.bimap(self, f, identity));\n/**\n * Returns a default `map` implementation.\n *\n * @since 1.0.0\n */\nexport const map = F => dual(2, (self, f) => F.bimap(self, identity, f));\n//# sourceMappingURL=Bicovariant.mjs.map","import { constant, flow, } from '@effect/data/Function';\nimport * as O from '@effect/data/Option';\nimport * as Tu from '@effect/data/Tuple';\nexport const of = (x) => [x, O.none()];\nexport const fromValueText = (v) => (t) => [v, O.some([t, O.none()])];\nexport const value = Tu.getFirst;\nexport const text = flow(Tu.getSecond, O.map(Tu.getFirst));\nexport const error = flow(Tu.getSecond, O.flatMap(Tu.getSecond));\nexport const setValue = flow(constant, (x) => Tu.mapFirst(x));\nexport const setText = (x) => Tu.mapSecond(flow(O.map(Tu.mapFirst(constant(x))), O.orElse(constant(O.some([x, O.none()])))));\nexport const hasError = flow(error, O.isSome);\n","import { constant, pipe, } from '@effect/data/Function';\nimport * as O from '@effect/data/Option';\nimport * as Ed from '@/Editable';\nexport default (subject) => (edit) => pipe(edit, Ed.error, O.map((x) => `${subject}${x === '' ? '' : ': '}${x}`), O.getOrElse(constant('')));\n","var util;\n(function (util) {\n    util.assertEqual = (val) => val;\n    function assertIs(_arg) { }\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items) => {\n        const obj = {};\n        for (const item of items) {\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj) => {\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys) {\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj) => {\n        return util.objectKeys(obj).map(function (e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\n        : (object) => {\n            const keys = [];\n            for (const key in object) {\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        };\n    util.find = (arr, checker) => {\n        for (const item of arr) {\n            if (checker(item))\n                return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\"\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n        : (val) => typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array\n            .map((val) => (typeof val === \"string\" ? `'${val}'` : val))\n            .join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value) => {\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nvar objectUtil;\n(function (objectUtil) {\n    objectUtil.mergeShapes = (first, second) => {\n        return {\n            ...first,\n            ...second, // second overwrites first\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nconst ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\",\n]);\nconst getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then &&\n                typeof data.then === \"function\" &&\n                data.catch &&\n                typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\n\nconst ZodIssueCode = util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\",\n]);\nconst quotelessJson = (obj) => {\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nclass ZodError extends Error {\n    constructor(issues) {\n        super();\n        this.issues = [];\n        this.addIssue = (sub) => {\n            this.issues = [...this.issues, sub];\n        };\n        this.addIssues = (subs = []) => {\n            this.issues = [...this.issues, ...subs];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        }\n        else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    get errors() {\n        return this.issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper ||\n            function (issue) {\n                return issue.message;\n            };\n        const fieldErrors = { _errors: [] };\n        const processError = (error) => {\n            for (const issue of error.issues) {\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                }\n                else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                }\n                else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                }\n                else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                }\n                else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while (i < issue.path.length) {\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || { _errors: [] };\n                            // if (typeof el === \"string\") {\n                            //   curr[el] = curr[el] || { _errors: [] };\n                            // } else if (typeof el === \"number\") {\n                            //   const errorArray: any = [];\n                            //   errorArray._errors = [];\n                            //   curr[el] = curr[el] || errorArray;\n                            // }\n                        }\n                        else {\n                            curr[el] = curr[el] || { _errors: [] };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue) => issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues) {\n            if (sub.path.length > 0) {\n                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n                fieldErrors[sub.path[0]].push(mapper(sub));\n            }\n            else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return { formErrors, fieldErrors };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nZodError.create = (issues) => {\n    const error = new ZodError(issues);\n    return error;\n};\n\nconst errorMap = (issue, _ctx) => {\n    let message;\n    switch (issue.code) {\n        case ZodIssueCode.invalid_type:\n            if (issue.received === ZodParsedType.undefined) {\n                message = \"Required\";\n            }\n            else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n            break;\n        case ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n            break;\n        case ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                }\n                else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                }\n                else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                }\n                else {\n                    util.assertNever(issue.validation);\n                }\n            }\n            else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            }\n            else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodIssueCode.too_small:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact\n                    ? `exactly equal to `\n                    : issue.inclusive\n                        ? `greater than or equal to `\n                        : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact\n                    ? `exactly equal to `\n                    : issue.inclusive\n                        ? `greater than or equal to `\n                        : `greater than `}${new Date(Number(issue.minimum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.too_big:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `less than or equal to`\n                        : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\")\n                message = `BigInt must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `less than or equal to`\n                        : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `smaller than or equal to`\n                        : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util.assertNever(issue);\n    }\n    return { message };\n};\n\nlet overrideErrorMap = errorMap;\nfunction setErrorMap(map) {\n    overrideErrorMap = map;\n}\nfunction getErrorMap() {\n    return overrideErrorMap;\n}\n\nconst makeIssue = (params) => {\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [...path, ...(issueData.path || [])];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath,\n    };\n    let errorMessage = \"\";\n    const maps = errorMaps\n        .filter((m) => !!m)\n        .slice()\n        .reverse();\n    for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: issueData.message || errorMessage,\n    };\n};\nconst EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n    const issue = makeIssue({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap,\n            ctx.schemaErrorMap,\n            getErrorMap(),\n            errorMap, // then global default map\n        ].filter((x) => !!x),\n    });\n    ctx.common.issues.push(issue);\n}\nclass ParseStatus {\n    constructor() {\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\")\n            this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\")\n            this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n            if (s.status === \"aborted\")\n                return INVALID;\n            if (s.status === \"dirty\")\n                status.dirty();\n            arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n            syncPairs.push({\n                key: await pair.key,\n                value: await pair.value,\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n            const { key, value } = pair;\n            if (key.status === \"aborted\")\n                return INVALID;\n            if (value.status === \"aborted\")\n                return INVALID;\n            if (key.status === \"dirty\")\n                status.dirty();\n            if (value.status === \"dirty\")\n                status.dirty();\n            if (typeof value.value !== \"undefined\" || pair.alwaysSet) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return { status: status.value, value: finalObject };\n    }\n}\nconst INVALID = Object.freeze({\n    status: \"aborted\",\n});\nconst DIRTY = (value) => ({ status: \"dirty\", value });\nconst OK = (value) => ({ status: \"valid\", value });\nconst isAborted = (x) => x.status === \"aborted\";\nconst isDirty = (x) => x.status === \"dirty\";\nconst isValid = (x) => x.status === \"valid\";\nconst isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\n\nvar errorUtil;\n(function (errorUtil) {\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message === null || message === void 0 ? void 0 : message.message;\n})(errorUtil || (errorUtil = {}));\n\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key) {\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (this._key instanceof Array) {\n                this._cachedPath.push(...this._path, ...this._key);\n            }\n            else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result) => {\n    if (isValid(result)) {\n        return { success: true, data: result.value };\n    }\n    else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error() {\n                if (this._error)\n                    return this._error;\n                const error = new ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            },\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params)\n        return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap)\n        return { errorMap: errorMap, description };\n    const customMap = (iss, ctx) => {\n        if (iss.code !== \"invalid_type\")\n            return { message: ctx.defaultError };\n        if (typeof ctx.data === \"undefined\") {\n            return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };\n        }\n        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };\n    };\n    return { errorMap: customMap, description };\n}\nclass ZodType {\n    constructor(def) {\n        /** Alias of safeParseAsync */\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n    }\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return getParsedType(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return (ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent,\n        });\n    }\n    _processInputParams(input) {\n        return {\n            status: new ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: getParsedType(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent,\n            },\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        var _a;\n        const ctx = {\n            common: {\n                issues: [],\n                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n        return handleResult(ctx, result);\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n                async: true,\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n        const result = await (isAsync(maybeAsyncResult)\n            ? maybeAsyncResult\n            : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val) => {\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return { message };\n            }\n            else if (typeof message === \"function\") {\n                return message(val);\n            }\n            else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx) => {\n            const result = check(val);\n            const setError = () => ctx.addIssue({\n                code: ZodIssueCode.custom,\n                ...getIssueProperties(val),\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data) => {\n                    if (!data) {\n                        setError();\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx) => {\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\"\n                    ? refinementData(val, ctx)\n                    : refinementData);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"refinement\", refinement },\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this, this._def);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([this, option], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"transform\", transform },\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def),\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description,\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[a-z][a-z0-9]*$/;\nconst ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;\nconst uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\nconst emailRegex = /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst emojiRegex = /^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$/u;\nconst ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;\nconst ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\n// Adapted from https://stackoverflow.com/a/3143231\nconst datetimeRegex = (args) => {\n    if (args.precision) {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{${args.precision}}(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n        }\n        else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{${args.precision}}Z$`);\n        }\n    }\n    else if (args.precision === 0) {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n        }\n        else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}Z$`);\n        }\n    }\n    else {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n        }\n        else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?Z$`);\n        }\n    }\n};\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nclass ZodString extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {\n            validation,\n            code: ZodIssueCode.invalid_string,\n            ...errorUtil.errToObj(message),\n        });\n        /**\n         * @deprecated Use z.string().min(1) instead.\n         * @see {@link ZodString.min}\n         */\n        this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));\n        this.trim = () => new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"trim\" }],\n        });\n        this.toLowerCase = () => new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n        });\n        this.toUpperCase = () => new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n        });\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.string,\n                received: ctx.parsedType,\n            }\n            //\n            );\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    else if (tooSmall) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"email\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"emoji\") {\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"emoji\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"uuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ulid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                }\n                catch (_a) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"regex\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            }\n            else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { includes: check.value, position: check.position },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            }\n            else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            }\n            else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { startsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { endsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ip\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    email(message) {\n        return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n    }\n    url(message) {\n        return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n    }\n    emoji(message) {\n        return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n    }\n    uuid(message) {\n        return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid(message) {\n        return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid2(message) {\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n    }\n    ulid(message) {\n        return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n    }\n    ip(options) {\n        return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n    }\n    datetime(options) {\n        var _a;\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\n        });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options === null || options === void 0 ? void 0 : options.position,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodString.create = (params) => {\n    var _a;\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params),\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / Math.pow(10, decCount);\n}\nclass ZodNumber extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.number,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"int\") {\n                if (!util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive\n                    ? input.data < check.value\n                    : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive\n                    ? input.data > check.value\n                    : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_finite,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil.toString(message),\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil.toString(message),\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil.toString(message),\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" ||\n            (ch.kind === \"multipleOf\" && util.isInteger(ch.value)));\n    }\n    get isFinite() {\n        let max = null, min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"finite\" ||\n                ch.kind === \"int\" ||\n                ch.kind === \"multipleOf\") {\n                return true;\n            }\n            else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n            else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nZodNumber.create = (params) => {\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBigInt extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = BigInt(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.bigint,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive\n                    ? input.data < check.value\n                    : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive\n                    ? input.data > check.value\n                    : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodBigInt.create = (params) => {\n    var _a;\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.boolean,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodBoolean.create = (params) => {\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.date,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_date,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime()),\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nZodDate.create = (params) => {\n    return new ZodDate({\n        checks: [],\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.symbol,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodSymbol.create = (params) => {\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.undefined,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodUndefined.create = (params) => {\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.null,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodNull.create = (params) => {\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params),\n    });\n};\nclass ZodAny extends ZodType {\n    constructor() {\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodAny.create = (params) => {\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnknown extends ZodType {\n    constructor() {\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodUnknown.create = (params) => {\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.never,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n}\nZodNever.create = (params) => {\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params),\n    });\n};\nclass ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.void,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodVoid.create = (params) => {\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params),\n    });\n};\nclass ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                addIssueToContext(ctx, {\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\n                    maximum: (tooBig ? def.exactLength.value : undefined),\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([...ctx.data].map((item, i) => {\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result) => {\n                return ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [...ctx.data].map((item, i) => {\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: { value: minLength, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: { value: maxLength, message: errorUtil.toString(message) },\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: { value: len, message: errorUtil.toString(message) },\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodArray.create = (schema, params) => {\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params),\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for (const key in schema.shape) {\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: () => newShape,\n        });\n    }\n    else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element),\n        });\n    }\n    else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n    }\n    else {\n        return schema;\n    }\n}\nclass ZodObject extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */\n        this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */\n        this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null)\n            return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        return (this._cached = { shape, keys });\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever &&\n            this._def.unknownKeys === \"strip\")) {\n            for (const key in ctx.data) {\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys) {\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: { status: \"valid\", value: key },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys) {\n                    pairs.push({\n                        key: { status: \"valid\", value: key },\n                        value: { status: \"valid\", value: ctx.data[key] },\n                    });\n                }\n            }\n            else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (unknownKeys === \"strip\") ;\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        }\n        else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys) {\n                const value = ctx.data[key];\n                pairs.push({\n                    key: { status: \"valid\", value: key },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data,\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve()\n                .then(async () => {\n                const syncPairs = [];\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    syncPairs.push({\n                        key,\n                        value: await pair.value,\n                        alwaysSet: pair.alwaysSet,\n                    });\n                }\n                return syncPairs;\n            })\n                .then((syncPairs) => {\n                return ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...(message !== undefined\n                ? {\n                    errorMap: (issue, ctx) => {\n                        var _a, _b, _c, _d;\n                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;\n                        if (issue.code === \"unrecognized_keys\")\n                            return {\n                                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,\n                            };\n                        return {\n                            message: defaultError,\n                        };\n                    },\n                }\n                : {}),\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\",\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\",\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: () => ({\n                ...this._def.shape(),\n                ...augmentation,\n            }),\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */\n    merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: () => ({\n                ...this._def.shape(),\n                ...merging._def.shape(),\n            }),\n            typeName: ZodFirstPartyTypeKind.ZodObject,\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({ [key]: schema });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index,\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        util.objectKeys(mask).forEach((key) => {\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        util.objectKeys(this.shape).forEach((key) => {\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    /**\n     * @deprecated\n     */\n    deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key) => {\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            }\n            else {\n                newShape[key] = fieldSchema.optional();\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key) => {\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            }\n            else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while (newField instanceof ZodOptional) {\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n    }\n}\nZodObject.create = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.strictCreate = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.lazycreate = (shape, params) => {\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results) {\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results) {\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option) => {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx,\n                    }),\n                    ctx: childCtx,\n                };\n            })).then(handleResults);\n        }\n        else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options) {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx,\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                }\n                else if (result.status === \"dirty\" && !dirty) {\n                    dirty = { result, ctx: childCtx };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues) => new ZodError(issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nZodUnion.create = (types, params) => {\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params),\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type) => {\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    }\n    else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    }\n    else if (type instanceof ZodLiteral) {\n        return [type.value];\n    }\n    else if (type instanceof ZodEnum) {\n        return type.options;\n    }\n    else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return Object.keys(type.enum);\n    }\n    else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else if (type instanceof ZodUndefined) {\n        return [undefined];\n    }\n    else if (type instanceof ZodNull) {\n        return [null];\n    }\n    else {\n        return null;\n    }\n};\nclass ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [discriminator],\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n        else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */\n    static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options) {\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues) {\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params),\n        });\n    }\n}\nfunction mergeValues(a, b) {\n    const aType = getParsedType(a);\n    const bType = getParsedType(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n        const bKeys = util.objectKeys(b);\n        const sharedKeys = util\n            .objectKeys(a)\n            .filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return { valid: false };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    else if (aType === ZodParsedType.date &&\n        bType === ZodParsedType.date &&\n        +a === +b) {\n        return { valid: true, data: a };\n    }\n    else {\n        return { valid: false };\n    }\n}\nclass ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight) => {\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n                return INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.invalid_intersection_types,\n                });\n                return INVALID;\n            }\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n                status.dirty();\n            }\n            return { status: status.value, value: merged.data };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n            ]).then(([left, right]) => handleParsed(left, right));\n        }\n        else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }));\n        }\n    }\n}\nZodIntersection.create = (left, right, params) => {\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params),\n    });\n};\nclass ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            status.dirty();\n        }\n        const items = [...ctx.data]\n            .map((item, itemIndex) => {\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema)\n                return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        })\n            .filter((x) => !!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results) => {\n                return ParseStatus.mergeArray(status, results);\n            });\n        }\n        else {\n            return ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest,\n        });\n    }\n}\nZodTuple.create = (schemas, params) => {\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params),\n    });\n};\nclass ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for (const key in ctx.data) {\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n            });\n        }\n        if (ctx.common.async) {\n            return ParseStatus.mergeObjectAsync(status, pairs);\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third),\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second),\n        });\n    }\n}\nclass ZodMap extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.map,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async () => {\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return { status: status.value, value: finalMap };\n            });\n        }\n        else {\n            const finalMap = new Map();\n            for (const pair of pairs) {\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return { status: status.value, value: finalMap };\n        }\n    }\n}\nZodMap.create = (keyType, valueType, params) => {\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.set,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message,\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements) {\n                if (element.status === \"aborted\")\n                    return INVALID;\n                if (element.status === \"dirty\")\n                    status.dirty();\n                parsedSet.add(element.value);\n            }\n            return { status: status.value, value: parsedSet };\n        }\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\n        }\n        else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: { value: minSize, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: { value: maxSize, message: errorUtil.toString(message) },\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodSet.create = (valueType, params) => {\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params),\n    });\n};\nclass ZodFunction extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.function,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return makeIssue({\n                data: args,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap,\n                ].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_arguments,\n                    argumentsError: error,\n                },\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return makeIssue({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap,\n                ].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_return_type,\n                    returnTypeError: error,\n                },\n            });\n        }\n        const params = { errorMap: ctx.common.contextualErrorMap };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            return OK(async (...args) => {\n                const error = new ZodError([]);\n                const parsedArgs = await this._def.args\n                    .parseAsync(args, params)\n                    .catch((e) => {\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await fn(...parsedArgs);\n                const parsedReturns = await this._def.returns._def.type\n                    .parseAsync(result, params)\n                    .catch((e) => {\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        }\n        else {\n            return OK((...args) => {\n                const parsedArgs = this._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n                }\n                const result = fn(...parsedArgs.data);\n                const parsedReturns = this._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType,\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: (args\n                ? args\n                : ZodTuple.create([]).rest(ZodUnknown.create())),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params),\n        });\n    }\n}\nclass ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n    }\n}\nZodLazy.create = (getter, params) => {\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params),\n    });\n};\nclass ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_literal,\n                expected: this._def.value,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nZodLiteral.create = (value, params) => {\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params),\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params),\n    });\n}\nclass ZodEnum extends ZodType {\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (this._def.values.indexOf(input.data) === -1) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values) {\n        return ZodEnum.create(values);\n    }\n    exclude(values) {\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));\n    }\n}\nZodEnum.create = createZodEnum;\nclass ZodNativeEnum extends ZodType {\n    _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string &&\n            ctx.parsedType !== ZodParsedType.number) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (nativeEnumValues.indexOf(input.data) === -1) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\nZodNativeEnum.create = (values, params) => {\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params),\n    });\n};\nclass ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise &&\n            ctx.common.async === false) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.promise,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise\n            ? ctx.data\n            : Promise.resolve(ctx.data);\n        return OK(promisified.then((data) => {\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap,\n            });\n        }));\n    }\n}\nZodPromise.create = (schema, params) => {\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params),\n    });\n};\nclass ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n            ? this._def.schema.sourceType()\n            : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data);\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then((processed) => {\n                    return this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                });\n            }\n            else {\n                return this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n        const checkCtx = {\n            addIssue: (arg) => {\n                addIssueToContext(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                }\n                else {\n                    status.dirty();\n                }\n            },\n            get path() {\n                return ctx.path;\n            },\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc\n            // effect: RefinementEffect<any>\n            ) => {\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inner.status === \"aborted\")\n                    return INVALID;\n                if (inner.status === \"dirty\")\n                    status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return { status: status.value, value: inner.value };\n            }\n            else {\n                return this._def.schema\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\n                    .then((inner) => {\n                    if (inner.status === \"aborted\")\n                        return INVALID;\n                    if (inner.status === \"dirty\")\n                        status.dirty();\n                    return executeRefinement(inner.value).then(() => {\n                        return { status: status.value, value: inner.value };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (!isValid(base))\n                    return base;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return { status: status.value, value: result };\n            }\n            else {\n                return this._def.schema\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\n                    .then((base) => {\n                    if (!isValid(base))\n                        return base;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));\n                });\n            }\n        }\n        util.assertNever(effect);\n    }\n}\nZodEffects.create = (schema, effect, params) => {\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params),\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n    return new ZodEffects({\n        schema,\n        effect: { type: \"preprocess\", transform: preprocess },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params),\n    });\n};\nclass ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n            return OK(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodOptional.create = (type, params) => {\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n            return OK(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodNullable.create = (type, params) => {\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nZodDefault.create = (type, params) => {\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\"\n            ? params.default\n            : () => params.default,\n        ...processCreateParams(params),\n    });\n};\nclass ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: [],\n            },\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx,\n            },\n        });\n        if (isAsync(result)) {\n            return result.then((result) => {\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\"\n                        ? result.value\n                        : this._def.catchValue({\n                            get error() {\n                                return new ZodError(newCtx.common.issues);\n                            },\n                            input: newCtx.data,\n                        }),\n                };\n            });\n        }\n        else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\"\n                    ? result.value\n                    : this._def.catchValue({\n                        get error() {\n                            return new ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data,\n                    }),\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nZodCatch.create = (type, params) => {\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.nan,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n}\nZodNaN.create = (params) => {\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params),\n    });\n};\nconst BRAND = Symbol(\"zod_brand\");\nclass ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nclass ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async () => {\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inResult.status === \"aborted\")\n                    return INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return DIRTY(inResult.value);\n                }\n                else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                }\n            };\n            return handleAsync();\n        }\n        else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n            if (inResult.status === \"aborted\")\n                return INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value,\n                };\n            }\n            else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\n        });\n    }\n}\nconst custom = (check, params = {}, \n/*\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */\nfatal) => {\n    if (check)\n        return ZodAny.create().superRefine((data, ctx) => {\n            var _a, _b;\n            if (!check(data)) {\n                const p = typeof params === \"function\"\n                    ? params(data)\n                    : typeof params === \"string\"\n                        ? { message: params }\n                        : params;\n                const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\n                const p2 = typeof p === \"string\" ? { message: p } : p;\n                ctx.addIssue({ code: \"custom\", ...p2, fatal: _fatal });\n            }\n        });\n    return ZodAny.create();\n};\nconst late = {\n    object: ZodObject.lazycreate,\n};\nvar ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\nconst instanceOfType = (\n// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`,\n}) => custom((data) => data instanceof cls, params);\nconst stringType = ZodString.create;\nconst numberType = ZodNumber.create;\nconst nanType = ZodNaN.create;\nconst bigIntType = ZodBigInt.create;\nconst booleanType = ZodBoolean.create;\nconst dateType = ZodDate.create;\nconst symbolType = ZodSymbol.create;\nconst undefinedType = ZodUndefined.create;\nconst nullType = ZodNull.create;\nconst anyType = ZodAny.create;\nconst unknownType = ZodUnknown.create;\nconst neverType = ZodNever.create;\nconst voidType = ZodVoid.create;\nconst arrayType = ZodArray.create;\nconst objectType = ZodObject.create;\nconst strictObjectType = ZodObject.strictCreate;\nconst unionType = ZodUnion.create;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nconst intersectionType = ZodIntersection.create;\nconst tupleType = ZodTuple.create;\nconst recordType = ZodRecord.create;\nconst mapType = ZodMap.create;\nconst setType = ZodSet.create;\nconst functionType = ZodFunction.create;\nconst lazyType = ZodLazy.create;\nconst literalType = ZodLiteral.create;\nconst enumType = ZodEnum.create;\nconst nativeEnumType = ZodNativeEnum.create;\nconst promiseType = ZodPromise.create;\nconst effectsType = ZodEffects.create;\nconst optionalType = ZodOptional.create;\nconst nullableType = ZodNullable.create;\nconst preprocessType = ZodEffects.createWithPreprocess;\nconst pipelineType = ZodPipeline.create;\nconst ostring = () => stringType().optional();\nconst onumber = () => numberType().optional();\nconst oboolean = () => booleanType().optional();\nconst coerce = {\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\n    boolean: ((arg) => ZodBoolean.create({\n        ...arg,\n        coerce: true,\n    })),\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\n};\nconst NEVER = INVALID;\n\nvar z = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    defaultErrorMap: errorMap,\n    setErrorMap: setErrorMap,\n    getErrorMap: getErrorMap,\n    makeIssue: makeIssue,\n    EMPTY_PATH: EMPTY_PATH,\n    addIssueToContext: addIssueToContext,\n    ParseStatus: ParseStatus,\n    INVALID: INVALID,\n    DIRTY: DIRTY,\n    OK: OK,\n    isAborted: isAborted,\n    isDirty: isDirty,\n    isValid: isValid,\n    isAsync: isAsync,\n    get util () { return util; },\n    get objectUtil () { return objectUtil; },\n    ZodParsedType: ZodParsedType,\n    getParsedType: getParsedType,\n    ZodType: ZodType,\n    ZodString: ZodString,\n    ZodNumber: ZodNumber,\n    ZodBigInt: ZodBigInt,\n    ZodBoolean: ZodBoolean,\n    ZodDate: ZodDate,\n    ZodSymbol: ZodSymbol,\n    ZodUndefined: ZodUndefined,\n    ZodNull: ZodNull,\n    ZodAny: ZodAny,\n    ZodUnknown: ZodUnknown,\n    ZodNever: ZodNever,\n    ZodVoid: ZodVoid,\n    ZodArray: ZodArray,\n    ZodObject: ZodObject,\n    ZodUnion: ZodUnion,\n    ZodDiscriminatedUnion: ZodDiscriminatedUnion,\n    ZodIntersection: ZodIntersection,\n    ZodTuple: ZodTuple,\n    ZodRecord: ZodRecord,\n    ZodMap: ZodMap,\n    ZodSet: ZodSet,\n    ZodFunction: ZodFunction,\n    ZodLazy: ZodLazy,\n    ZodLiteral: ZodLiteral,\n    ZodEnum: ZodEnum,\n    ZodNativeEnum: ZodNativeEnum,\n    ZodPromise: ZodPromise,\n    ZodEffects: ZodEffects,\n    ZodTransformer: ZodEffects,\n    ZodOptional: ZodOptional,\n    ZodNullable: ZodNullable,\n    ZodDefault: ZodDefault,\n    ZodCatch: ZodCatch,\n    ZodNaN: ZodNaN,\n    BRAND: BRAND,\n    ZodBranded: ZodBranded,\n    ZodPipeline: ZodPipeline,\n    custom: custom,\n    Schema: ZodType,\n    ZodSchema: ZodType,\n    late: late,\n    get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },\n    coerce: coerce,\n    any: anyType,\n    array: arrayType,\n    bigint: bigIntType,\n    boolean: booleanType,\n    date: dateType,\n    discriminatedUnion: discriminatedUnionType,\n    effect: effectsType,\n    'enum': enumType,\n    'function': functionType,\n    'instanceof': instanceOfType,\n    intersection: intersectionType,\n    lazy: lazyType,\n    literal: literalType,\n    map: mapType,\n    nan: nanType,\n    nativeEnum: nativeEnumType,\n    never: neverType,\n    'null': nullType,\n    nullable: nullableType,\n    number: numberType,\n    object: objectType,\n    oboolean: oboolean,\n    onumber: onumber,\n    optional: optionalType,\n    ostring: ostring,\n    pipeline: pipelineType,\n    preprocess: preprocessType,\n    promise: promiseType,\n    record: recordType,\n    set: setType,\n    strictObject: strictObjectType,\n    string: stringType,\n    symbol: symbolType,\n    transformer: effectsType,\n    tuple: tupleType,\n    'undefined': undefinedType,\n    union: unionType,\n    unknown: unknownType,\n    'void': voidType,\n    NEVER: NEVER,\n    ZodIssueCode: ZodIssueCode,\n    quotelessJson: quotelessJson,\n    ZodError: ZodError\n});\n\nexport { BRAND, DIRTY, EMPTY_PATH, INVALID, NEVER, OK, ParseStatus, ZodType as Schema, ZodAny, ZodArray, ZodBigInt, ZodBoolean, ZodBranded, ZodCatch, ZodDate, ZodDefault, ZodDiscriminatedUnion, ZodEffects, ZodEnum, ZodError, ZodFirstPartyTypeKind, ZodFunction, ZodIntersection, ZodIssueCode, ZodLazy, ZodLiteral, ZodMap, ZodNaN, ZodNativeEnum, ZodNever, ZodNull, ZodNullable, ZodNumber, ZodObject, ZodOptional, ZodParsedType, ZodPipeline, ZodPromise, ZodRecord, ZodType as ZodSchema, ZodSet, ZodString, ZodSymbol, ZodEffects as ZodTransformer, ZodTuple, ZodType, ZodUndefined, ZodUnion, ZodUnknown, ZodVoid, addIssueToContext, anyType as any, arrayType as array, bigIntType as bigint, booleanType as boolean, coerce, custom, dateType as date, z as default, errorMap as defaultErrorMap, discriminatedUnionType as discriminatedUnion, effectsType as effect, enumType as enum, functionType as function, getErrorMap, getParsedType, instanceOfType as instanceof, intersectionType as intersection, isAborted, isAsync, isDirty, isValid, late, lazyType as lazy, literalType as literal, makeIssue, mapType as map, nanType as nan, nativeEnumType as nativeEnum, neverType as never, nullType as null, nullableType as nullable, numberType as number, objectType as object, objectUtil, oboolean, onumber, optionalType as optional, ostring, pipelineType as pipeline, preprocessType as preprocess, promiseType as promise, quotelessJson, recordType as record, setType as set, setErrorMap, strictObjectType as strictObject, stringType as string, symbolType as symbol, effectsType as transformer, tupleType as tuple, undefinedType as undefined, unionType as union, unknownType as unknown, util, voidType as void, z };\n","import { z, } from 'zod';\nexport default (e) => z.instanceof(HTMLInputElement).parse(e.currentTarget).checked;\n","export default (e) => {\n    // eslint-disable-next-line max-len\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/consistent-type-assertions, @typescript-eslint/dot-notation\n    const target = e.currentTarget ?? e['__target'];\n    if (target instanceof HTMLSelectElement\n        || target instanceof HTMLTextAreaElement\n        || target instanceof HTMLInputElement) {\n        return target.value;\n    }\n    throw Error('Event target type isn\\'t acceptable.');\n};\n","import { h, text, } from 'hyperapp';\nexport default (value, label, selected) => h('option', {\n    value,\n    selected,\n}, text(label));\n","export default (width) => ({\n    flex: `0 0 ${width}px`,\n    width: `${width}px`,\n    margin: '2px',\n});\n","import { constant, pipe, } from '@effect/data/Function';\nimport * as O from '@effect/data/Option';\nimport { h, } from 'hyperapp';\nimport * as Ed from '@/Editable';\nexport default (min, max, step, action) => (value) => h('div', {}, [\n    h('input', {\n        style: {\n            width: '150px',\n            verticalAlign: 'middle',\n        },\n        type: 'range',\n        min,\n        max,\n        step,\n        value: Ed.value(value).toString(),\n        oninput: action.onchange,\n    }),\n    h('input', {\n        style: {\n            width: '30px',\n            backgroundColor: 'transparent',\n            color: 'inherit',\n            borderWidth: '1px',\n            verticalAlign: 'middle',\n            borderColor: Ed.hasError(value) ? '#f55' : undefined,\n        },\n        inputmode: 'decimal',\n        value: pipe(value, Ed.text, O.getOrElse(constant(Ed.value(value).toFixed(4).replace(/\\.?0+$/, '')))),\n        ...action,\n    }),\n]);\n","import { h, text, } from 'hyperapp';\nexport default (label, error, content) => h('div', {}, [\n    h('span', {}, text(label)),\n    h('span', {\n        style: {\n            color: '#f55',\n            marginLeft: '5px',\n            whiteSpace: 'pre-wrap',\n        },\n    }, text(error)),\n    h('div', {}, content),\n]);\n","/**\n * This module provides utility functions and type class instances for working with the `string` type in TypeScript.\n * It includes functions for basic string manipulation, as well as type class instances for\n * `Equivalence`, `Order`, `Semigroup`, and `Monoid`.\n *\n * @since 1.0.0\n */\nimport { dual } from \"@effect/data/Function\";\nimport * as readonlyArray from \"@effect/data/internal/ReadonlyArray\";\nimport * as predicate from \"@effect/data/Predicate\";\nimport * as equivalence from \"@effect/data/typeclass/Equivalence\";\nimport * as monoid from \"@effect/data/typeclass/Monoid\";\nimport * as order from \"@effect/data/typeclass/Order\";\nimport * as semigroup from \"@effect/data/typeclass/Semigroup\";\n/**\n * Tests if a value is a `string`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isString } from '@effect/data/String'\n *\n * assert.deepStrictEqual(isString(\"a\"), true)\n * assert.deepStrictEqual(isString(1), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexport const isString = predicate.isString;\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Equivalence = equivalence.string;\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Order = order.string;\n/**\n * `string` semigroup under concatenation.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const Semigroup = semigroup.string;\n/**\n * `string` monoid under concatenation.\n *\n * The `empty` value is `''`.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const Monoid = monoid.string;\n/**\n * The empty string `\"\"`.\n *\n * @since 1.0.0\n */\nexport const empty = \"\";\n/**\n * @since 1.0.0\n */\nexport const concat = /*#__PURE__*/dual(2, Semigroup.combine);\n/**\n * @example\n * import * as S from '@effect/data/String'\n * import { pipe } from '@effect/data/Function'\n *\n * assert.deepStrictEqual(pipe('a', S.toUpperCase), 'A')\n *\n * @since 1.0.0\n */\nexport const toUpperCase = self => self.toUpperCase();\n/**\n * @example\n * import * as S from '@effect/data/String'\n * import { pipe } from '@effect/data/Function'\n *\n * assert.deepStrictEqual(pipe('A', S.toLowerCase), 'a')\n *\n * @since 1.0.0\n */\nexport const toLowerCase = self => self.toLowerCase();\n/**\n * @example\n * import * as S from '@effect/data/String'\n * import { pipe } from '@effect/data/Function'\n *\n * assert.deepStrictEqual(pipe('abc', S.replace('b', 'd')), 'adc')\n *\n * @since 1.0.0\n */\nexport const replace = /*#__PURE__*/dual(3, (self, searchValue, replaceValue) => self.replace(searchValue, replaceValue));\n/**\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.trim(' a '), 'a')\n *\n * @since 1.0.0\n */\nexport const trim = self => self.trim();\n/**\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.trimStart(' a '), 'a ')\n *\n * @since 1.0.0\n */\nexport const trimStart = self => self.trimStart();\n/**\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.trimEnd(' a '), ' a')\n *\n * @since 1.0.0\n */\nexport const trimEnd = self => self.trimEnd();\n/**\n * @example\n * import * as S from '@effect/data/String'\n * import { pipe } from '@effect/data/Function'\n *\n * assert.deepStrictEqual(pipe('abcd', S.slice(1, 3)), 'bc')\n *\n * @since 1.0.0\n */\nexport const slice = /*#__PURE__*/dual(3, (self, start, end) => self.slice(start, end));\n/**\n * Test whether a `string` is empty.\n *\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.isEmpty(''), true)\n * assert.deepStrictEqual(S.isEmpty('a'), false)\n *\n * @since 1.0.0\n */\nexport const isEmpty = self => self.length === 0;\n/**\n * Test whether a `string` is non empty.\n *\n * @since 1.0.0\n */\nexport const isNonEmpty = self => self.length > 0;\n/**\n * Calculate the number of characters in a `string`.\n *\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.length('abc'), 3)\n *\n * @since 1.0.0\n */\nexport const length = self => self.length;\n/**\n * @example\n * import * as S from '@effect/data/String'\n * import { pipe } from '@effect/data/Function'\n *\n * assert.deepStrictEqual(pipe('abc', S.split('')), ['a', 'b', 'c'])\n * assert.deepStrictEqual(pipe('', S.split('')), [''])\n *\n * @since 1.0.0\n */\nexport const split = /*#__PURE__*/dual(2, (self, separator) => {\n  const out = self.split(separator);\n  return readonlyArray.isNonEmptyArray(out) ? out : [self];\n});\n/**\n * Returns `true` if `searchString` appears as a substring of `self`, at one or more positions that are\n * greater than or equal to `0`; otherwise, returns `false`.\n *\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.includes(\"abc\", \"b\"), true)\n * assert.deepStrictEqual(S.includes(\"abc\", \"d\"), false)\n *\n * @since 1.0.0\n */\nexport const includes = /*#__PURE__*/dual(2, (self, searchString) => self.includes(searchString));\n/**\n * Returns `true` if `searchString` appears as a substring of `self`, at one or more positions that are\n * greater than or equal to `position`; otherwise, returns `false`.\n *\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.includesWithPosition(\"abc\", \"b\", 1), true)\n * assert.deepStrictEqual(S.includesWithPosition(\"abc\", \"a\", 1), false)\n *\n * @since 1.0.0\n */\nexport const includesWithPosition = /*#__PURE__*/dual(3, (self, searchString, position) => self.includes(searchString, position));\n/**\n * Returns `true` if the sequence of elements of `searchString` is the\n * same as the corresponding elements of `s` starting at\n * position. Otherwise returns false.\n *\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.startsWith(\"abc\", \"a\"), true)\n * assert.deepStrictEqual(S.startsWith(\"bc\", \"a\"), false)\n *\n * @since 1.0.0\n */\nexport const startsWith = /*#__PURE__*/dual(2, (self, searchString) => self.startsWith(searchString));\n/**\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.startsWithPosition(\"abc\", \"b\", 1), true)\n * assert.deepStrictEqual(S.startsWithPosition(\"bc\", \"a\", 1), false)\n *\n * @since 1.0.0\n */\nexport const startsWithPosition = /*#__PURE__*/dual(3, (self, searchString, position) => self.startsWith(searchString, position));\n/**\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.endsWith(\"abc\", \"c\"), true)\n * assert.deepStrictEqual(S.endsWith(\"ab\", \"c\"), false)\n *\n * @since 1.0.0\n */\nexport const endsWith = /*#__PURE__*/dual(2, (self, searchString) => self.endsWith(searchString));\n/**\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.endsWithPosition(\"abc\", \"b\", 2), true)\n * assert.deepStrictEqual(S.endsWithPosition(\"abc\", \"c\", 2), false)\n *\n * @since 1.0.0\n */\nexport const endsWithPosition = /*#__PURE__*/dual(3, (self, searchString, position) => self.endsWith(searchString, position));\n/**\n * Keep the specified number of characters from the start of a string.\n *\n * If `n` is larger than the available number of characters, the string will\n * be returned whole.\n *\n * If `n` is not a positive number, an empty string will be returned.\n *\n * If `n` is a float, it will be rounded down to the nearest integer.\n *\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.takeLeft(\"Hello World\", 5), \"Hello\")\n *\n * @since 1.0.0\n */\nexport const takeLeft = /*#__PURE__*/dual(2, (self, n) => self.slice(0, Math.max(n, 0)));\n/**\n * Keep the specified number of characters from the end of a string.\n *\n * If `n` is larger than the available number of characters, the string will\n * be returned whole.\n *\n * If `n` is not a positive number, an empty string will be returned.\n *\n * If `n` is a float, it will be rounded down to the nearest integer.\n *\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.takeRight(\"Hello World\", 5), \"World\")\n *\n * @since 1.0.0\n */\nexport const takeRight = /*#__PURE__*/dual(2, (self, n) => self.slice(Math.max(0, self.length - Math.floor(n)), Infinity));\n/*\n\n  Missing:\n\n  - charCodeAt\n  - substring\n  - at\n  - charAt\n  - codePointAt\n  - indexOf\n  - lastIndexOf\n  - localeCompare\n  - match\n  - matchAll\n  - normalize\n  - padEnd\n  - padStart\n  - repeat\n  - replaceAll\n  - search\n  - toLocaleLowerCase\n  - toLocaleUpperCase\n*/\nconst CR = 0x0d;\nconst LF = 0x0a;\n/**\n * Returns an `IterableIterator` which yields each line contained within the\n * string, trimming off the trailing newline character.\n *\n * @since 1.0.0\n */\n// export const linesIterator = (self: string): LinesIterator => linesSeparated(self, true)\n/**\n * Returns an `IterableIterator` which yields each line contained within the\n * string as well as the trailing newline character.\n *\n * @since 1.0.0\n */\nexport const linesWithSeparators = s => linesSeparated(s, false);\n/**\n * For every line in this string, strip a leading prefix consisting of blanks\n * or control characters followed by the character specified by `marginChar`\n * from the line.\n *\n * @since 1.0.0\n */\nexport const stripMarginWith = /*#__PURE__*/dual(2, (self, marginChar) => {\n  let out = \"\";\n  for (const line of linesWithSeparators(self)) {\n    let index = 0;\n    while (index < line.length && line.charAt(index) <= \" \") {\n      index = index + 1;\n    }\n    const stripped = index < line.length && line.charAt(index) === marginChar ? line.substring(index + 1) : line;\n    out = out + stripped;\n  }\n  return out;\n});\n/**\n * For every line in this string, strip a leading prefix consisting of blanks\n * or control characters followed by the `\"|\"` character from the line.\n *\n * @since 1.0.0\n */\nexport const stripMargin = self => stripMarginWith(\"|\")(self);\nclass LinesIterator {\n  constructor(s, stripped = false) {\n    this.s = s;\n    this.stripped = stripped;\n    this.index = 0;\n    this.length = s.length;\n  }\n  next() {\n    if (this.done) {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n    const start = this.index;\n    while (!this.done && !isLineBreak(this.s[this.index])) {\n      this.index = this.index + 1;\n    }\n    let end = this.index;\n    if (!this.done) {\n      const char = this.s[this.index];\n      this.index = this.index + 1;\n      if (!this.done && isLineBreak2(char, this.s[this.index])) {\n        this.index = this.index + 1;\n      }\n      if (!this.stripped) {\n        end = this.index;\n      }\n    }\n    return {\n      done: false,\n      value: this.s.substring(start, end)\n    };\n  }\n  [Symbol.iterator]() {\n    return new LinesIterator(this.s, this.stripped);\n  }\n  get done() {\n    return this.index >= this.length;\n  }\n}\n/**\n * Test if the provided character is a line break character (i.e. either `\"\\r\"`\n * or `\"\\n\"`).\n */\nconst isLineBreak = char => {\n  const code = char.charCodeAt(0);\n  return code === CR || code === LF;\n};\n/**\n * Test if the provided characters combine to form a carriage return/line-feed\n * (i.e. `\"\\r\\n\"`).\n */\nconst isLineBreak2 = (char0, char1) => char0.charCodeAt(0) === CR && char1.charCodeAt(0) === LF;\nconst linesSeparated = (self, stripped) => new LinesIterator(self, stripped);\n//# sourceMappingURL=String.mjs.map","/**\n * This module provides utility functions for working with arrays in TypeScript.\n *\n * @since 1.0.0\n */\nimport * as E from \"@effect/data/Either\";\nimport { dual, identity } from \"@effect/data/Function\";\nimport * as readonlyArray from \"@effect/data/internal/ReadonlyArray\";\nimport * as O from \"@effect/data/Option\";\nimport * as RR from \"@effect/data/ReadonlyRecord\";\nimport * as string from \"@effect/data/String\";\nimport * as applicative from \"@effect/data/typeclass/Applicative\";\nimport * as chainable from \"@effect/data/typeclass/Chainable\";\nimport * as covariant from \"@effect/data/typeclass/Covariant\";\nimport * as equivalence from \"@effect/data/typeclass/Equivalence\";\nimport * as flatMap_ from \"@effect/data/typeclass/FlatMap\";\nimport * as foldable from \"@effect/data/typeclass/Foldable\";\nimport * as invariant from \"@effect/data/typeclass/Invariant\";\nimport * as monoid from \"@effect/data/typeclass/Monoid\";\nimport * as of_ from \"@effect/data/typeclass/Of\";\nimport * as order from \"@effect/data/typeclass/Order\";\nimport * as semiApplicative from \"@effect/data/typeclass/SemiApplicative\";\nimport * as semigroup from \"@effect/data/typeclass/Semigroup\";\nimport * as semiProduct from \"@effect/data/typeclass/SemiProduct\";\nimport * as traversable from \"@effect/data/typeclass/Traversable\";\nimport * as traversableFilterable from \"@effect/data/typeclass/TraversableFilterable\";\n/**\n * Builds a `NonEmptyArray` from an non-empty collection of elements.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const make = (...elements) => elements;\n/**\n * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * @example\n * import { makeBy } from '@effect/data/ReadonlyArray'\n *\n * assert.deepStrictEqual(makeBy(5, n => n * 2), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const makeBy = (n, f) => {\n  const max = Math.max(1, Math.floor(n));\n  const out = [f(0)];\n  for (let i = 1; i < max; i++) {\n    out.push(f(i));\n  }\n  return out;\n};\n/**\n * Return a `NonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from '@effect/data/ReadonlyArray'\n *\n * assert.deepStrictEqual(range(1, 3), [1, 2, 3])\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const range = (start, end) => start <= end ? makeBy(end - start + 1, i => start + i) : [start];\n/**\n * Return a `NonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * @example\n * import { replicate } from '@effect/data/ReadonlyArray'\n *\n * assert.deepStrictEqual(replicate(\"a\", 3), [\"a\", \"a\", \"a\"])\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const replicate = /*#__PURE__*/dual(2, (a, n) => makeBy(n, () => a));\n/**\n * @category conversions\n * @since 1.0.0\n */\nexport const fromIterable = readonlyArray.fromIterable;\n/**\n * Takes a record and returns an array of tuples containing its keys and values.\n *\n * @param self - The record to transform.\n *\n * @example\n * import { fromRecord } from \"@effect/data/ReadonlyArray\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * assert.deepStrictEqual(fromRecord(x), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n *\n * @category conversions\n * @since 1.0.0\n */\nexport const fromRecord = RR.toEntries;\n/**\n * @category conversions\n * @since 1.0.0\n */\nexport const fromOption = O.toArray;\n/**\n * @category conversions\n * @since 1.0.0\n */\nexport const fromEither = E.toArray;\n/**\n * @category pattern matching\n * @since 1.0.0\n */\nexport const match = /*#__PURE__*/dual(3, (self, onEmpty, onNonEmpty) => isNonEmptyReadonlyArray(self) ? onNonEmpty(self) : onEmpty());\n/**\n * @category pattern matching\n * @since 1.0.0\n */\nexport const matchLeft = /*#__PURE__*/dual(3, (self, onEmpty, onNonEmpty) => isNonEmptyReadonlyArray(self) ? onNonEmpty(headNonEmpty(self), tailNonEmpty(self)) : onEmpty());\n/**\n * @category pattern matching\n * @since 1.0.0\n */\nexport const matchRight = /*#__PURE__*/dual(3, (self, onEmpty, onNonEmpty) => isNonEmptyReadonlyArray(self) ? onNonEmpty(initNonEmpty(self), lastNonEmpty(self)) : onEmpty());\n/**\n * Prepend an element to the front of an `Iterable`, creating a new `NonEmptyArray`.\n *\n * @since 1.0.0\n */\nexport const prepend = /*#__PURE__*/dual(2, (self, head) => [head, ...self]);\n/**\n * @since 1.0.0\n */\nexport const prependAll = /*#__PURE__*/dual(2, (self, that) => fromIterable(that).concat(fromIterable(self)));\n/**\n * @since 1.0.0\n */\nexport const prependAllNonEmpty = /*#__PURE__*/dual(2, (self, that) => prependAll(self, that));\n/**\n * Append an element to the end of an `Iterable`, creating a new `NonEmptyArray`.\n *\n * @since 1.0.0\n */\nexport const append = /*#__PURE__*/dual(2, (self, last) => [...self, last]);\n/**\n * @since 1.0.0\n */\nexport const appendAll = /*#__PURE__*/dual(2, (self, that) => fromIterable(self).concat(fromIterable(that)));\n/**\n * @since 1.0.0\n */\nexport const appendAllNonEmpty = /*#__PURE__*/dual(2, (self, that) => appendAll(self, that));\n/**\n * Reduce an `Iterable` from the left, keeping all intermediate results instead of only the final result.\n *\n * @category folding\n * @since 1.0.0\n */\nexport const scan = /*#__PURE__*/dual(3, (self, b, f) => {\n  const out = [b];\n  let i = 0;\n  for (const a of self) {\n    out[i + 1] = f(out[i], a);\n    i++;\n  }\n  return out;\n});\n/**\n * Reduce an `Iterable` from the right, keeping all intermediate results instead of only the final result.\n *\n * @category folding\n * @since 1.0.0\n */\nexport const scanRight = /*#__PURE__*/dual(3, (self, b, f) => {\n  const input = fromIterable(self);\n  const out = new Array(input.length + 1);\n  out[input.length] = b;\n  for (let i = input.length - 1; i >= 0; i--) {\n    out[i] = f(out[i + 1], input[i]);\n  }\n  return out;\n});\n/**\n * Determine if an `Array` is empty narrowing down the type to `[]`.\n *\n * @param self - The `Array` to check.\n *\n * @example\n * import { isEmptyArray } from \"@effect/data/ReadonlyArray\"\n *\n * assert.deepStrictEqual(isEmptyArray([]), true);\n * assert.deepStrictEqual(isEmptyArray([1, 2, 3]), false);\n *\n * @category guards\n * @since 1.0.0\n */\nexport const isEmptyArray = self => self.length === 0;\n/**\n * Determine if a `ReadonlyArray` is empty narrowing down the type to `readonly []`.\n *\n * @param self - The `ReadonlyArray` to check.\n *\n * @example\n * import { isEmptyReadonlyArray } from \"@effect/data/ReadonlyArray\"\n *\n * assert.deepStrictEqual(isEmptyReadonlyArray([]), true);\n * assert.deepStrictEqual(isEmptyReadonlyArray([1, 2, 3]), false);\n *\n * @category guards\n * @since 1.0.0\n */\nexport const isEmptyReadonlyArray = isEmptyArray;\n/**\n * Determine if an `Array` is non empty narrowing down the type to `NonEmptyArray`.\n *\n * An `Array` is considered to be a `NonEmptyArray` if it contains at least one element.\n *\n * @param self - The `Array` to check.\n *\n * @example\n * import { isNonEmptyArray } from \"@effect/data/ReadonlyArray\"\n *\n * assert.deepStrictEqual(isNonEmptyArray([]), false);\n * assert.deepStrictEqual(isNonEmptyArray([1, 2, 3]), true);\n *\n * @category guards\n * @since 1.0.0\n */\nexport const isNonEmptyArray = readonlyArray.isNonEmptyArray;\n/**\n * Determine if a `ReadonlyArray` is non empty narrowing down the type to `NonEmptyReadonlyArray`.\n *\n * A `ReadonlyArray` is considered to be a `NonEmptyReadonlyArray` if it contains at least one element.\n *\n * @param self - The `ReadonlyArray` to check.\n *\n * @example\n * import { isNonEmptyReadonlyArray } from \"@effect/data/ReadonlyArray\"\n *\n * assert.deepStrictEqual(isNonEmptyReadonlyArray([]), false);\n * assert.deepStrictEqual(isNonEmptyReadonlyArray([1, 2, 3]), true);\n *\n * @category guards\n * @since 1.0.0\n */\nexport const isNonEmptyReadonlyArray = readonlyArray.isNonEmptyArray;\n/**\n * Return the number of elements in a `ReadonlyArray`.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const length = self => self.length;\nconst isOutOfBound = (i, as) => i < 0 || i >= as.length;\nconst clamp = (i, as) => Math.floor(Math.min(Math.max(0, i), as.length));\n/**\n * This function provides a safe way to read a value at a particular index from a `ReadonlyArray`.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const get = /*#__PURE__*/dual(2, (self, index) => {\n  const i = Math.floor(index);\n  return isOutOfBound(i, self) ? O.none() : O.some(self[i]);\n});\n/**\n * Gets an element unsafely, will throw on out of bounds.\n *\n * @since 1.0.0\n * @category unsafe\n */\nexport const unsafeGet = /*#__PURE__*/dual(2, (self, index) => {\n  const i = Math.floor(index);\n  if (isOutOfBound(i, self)) {\n    throw new Error(`Index ${i} out of bounds`);\n  }\n  return self[i];\n});\n/**\n * Return a tuple containing the first element, and a new `Array` of the remaining elements, if any.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const unprepend = self => [headNonEmpty(self), tailNonEmpty(self)];\n/**\n * Return a tuple containing a copy of the `NonEmptyReadonlyArray` without its last element, and that last element.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const unappend = self => [initNonEmpty(self), lastNonEmpty(self)];\n/**\n * Get the first element of a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const head = /*#__PURE__*/get(0);\n/**\n * @category getters\n * @since 1.0.0\n */\nexport const headNonEmpty = /*#__PURE__*/unsafeGet(0);\n/**\n * Get the last element in a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const last = self => isNonEmptyReadonlyArray(self) ? O.some(lastNonEmpty(self)) : O.none();\n/**\n * @category getters\n * @since 1.0.0\n */\nexport const lastNonEmpty = self => self[self.length - 1];\n/**\n * Get all but the first element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const tail = self => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? O.some(tailNonEmpty(input)) : O.none();\n};\n/**\n * @category getters\n * @since 1.0.0\n */\nexport const tailNonEmpty = self => self.slice(1);\n/**\n * Get all but the last element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const init = self => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? O.some(initNonEmpty(input)) : O.none();\n};\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const initNonEmpty = self => self.slice(0, -1);\n/**\n * Keep only a max number of elements from the start of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const take = /*#__PURE__*/dual(2, (self, n) => {\n  const input = fromIterable(self);\n  return input.slice(0, clamp(n, input));\n});\n/**\n * Keep only a max number of elements from the end of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const takeRight = /*#__PURE__*/dual(2, (self, n) => {\n  const input = fromIterable(self);\n  const i = clamp(n, input);\n  return i === 0 ? [] : input.slice(-i);\n});\n/**\n * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const takeWhile = /*#__PURE__*/dual(2, (self, predicate) => {\n  const out = [];\n  for (const a of self) {\n    if (!predicate(a)) {\n      break;\n    }\n    out.push(a);\n  }\n  return out;\n});\nconst spanIndex = (self, predicate) => {\n  let i = 0;\n  for (const a of self) {\n    if (!predicate(a)) {\n      break;\n    }\n    i++;\n  }\n  return i;\n};\n/**\n * Split an `Iterable` into two parts:\n *\n * 1. the longest initial subarray for which all elements satisfy the specified predicate\n * 2. the remaining elements\n *\n * @category filtering\n * @since 1.0.0\n */\nexport const span = /*#__PURE__*/dual(2, (self, predicate) => splitAt(self, spanIndex(self, predicate)));\n/**\n * Drop a max number of elements from the start of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const drop = /*#__PURE__*/dual(2, (self, n) => {\n  const input = fromIterable(self);\n  return input.slice(clamp(n, input), input.length);\n});\n/**\n * Drop a max number of elements from the end of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const dropRight = /*#__PURE__*/dual(2, (self, n) => {\n  const input = fromIterable(self);\n  return input.slice(0, input.length - clamp(n, input));\n});\n/**\n * Remove the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const dropWhile = /*#__PURE__*/dual(2, (self, predicate) => fromIterable(self).slice(spanIndex(self, predicate)));\n/**\n * Return the first index for which a predicate holds.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const findFirstIndex = /*#__PURE__*/dual(2, (self, predicate) => {\n  let i = 0;\n  for (const a of self) {\n    if (predicate(a)) {\n      return O.some(i);\n    }\n    i++;\n  }\n  return O.none();\n});\n/**\n * Return the last index for which a predicate holds.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const findLastIndex = /*#__PURE__*/dual(2, (self, predicate) => {\n  const input = fromIterable(self);\n  for (let i = input.length - 1; i >= 0; i--) {\n    if (predicate(input[i])) {\n      return O.some(i);\n    }\n  }\n  return O.none();\n});\n/**\n * Find the first element for which a predicate holds.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const findFirst = /*#__PURE__*/dual(2, (self, predicate) => {\n  const input = fromIterable(self);\n  for (let i = 0; i < input.length; i++) {\n    if (predicate(input[i])) {\n      return O.some(input[i]);\n    }\n  }\n  return O.none();\n});\n/**\n * Find the last element for which a predicate holds.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const findLast = /*#__PURE__*/dual(2, (self, predicate) => {\n  const input = fromIterable(self);\n  for (let i = input.length - 1; i >= 0; i--) {\n    if (predicate(input[i])) {\n      return O.some(input[i]);\n    }\n  }\n  return O.none();\n});\n/**\n * Insert an element at the specified index, creating a new `NonEmptyArray`,\n * or return `None` if the index is out of bounds.\n *\n * @since 1.0.0\n */\nexport const insertAt = /*#__PURE__*/dual(3, (self, i, b) => {\n  const out = Array.from(self);\n  //             v--- `= self.length` is ok, it means inserting in last position\n  if (i < 0 || i > out.length) {\n    return O.none();\n  }\n  out.splice(i, 0, b);\n  return O.some(out);\n});\n/**\n * Change the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * @since 1.0.0\n */\nexport const replace = /*#__PURE__*/dual(3, (self, i, b) => modify(self, i, () => b));\n/**\n * @since 1.0.0\n */\nexport const replaceOption = /*#__PURE__*/dual(3, (self, i, b) => modifyOption(self, i, () => b));\n/**\n * Apply a function to the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * @since 1.0.0\n */\nexport const modify = /*#__PURE__*/dual(3, (self, i, f) => O.getOrElse(modifyOption(self, i, f), () => Array.from(self)));\n/**\n * Apply a function to the element at the specified index, creating a new `Array`,\n * or return `None` if the index is out of bounds.\n *\n * @since 1.0.0\n */\nexport const modifyOption = /*#__PURE__*/dual(3, (self, i, f) => {\n  const out = Array.from(self);\n  if (isOutOfBound(i, out)) {\n    return O.none();\n  }\n  const next = f(out[i]);\n  // @ts-expect-error\n  out[i] = next;\n  return O.some(out);\n});\n/**\n * Delete the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * @since 1.0.0\n */\nexport const remove = /*#__PURE__*/dual(2, (self, i) => {\n  const out = Array.from(self);\n  if (isOutOfBound(i, out)) {\n    return out;\n  }\n  out.splice(i, 1);\n  return out;\n});\n/**\n * Reverse an `Iterable`, creating a new `Array`.\n *\n * @since 1.0.0\n */\nexport const reverse = self => Array.from(self).reverse();\n/**\n * @since 1.0.0\n */\nexport const reverseNonEmpty = self => [lastNonEmpty(self), ...self.slice(0, -1).reverse()];\n/**\n * Return all the `Right` elements from an `Interable` of `Either`s.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const rights = E.rights;\n/**\n * Return all the `Left` elements from an `Interable` of `Either`s.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const lefts = E.lefts;\n/**\n * Sort the elements of an `Iterable` in increasing order, creating a new `Array`.\n *\n * @category sorting\n * @since 1.0.0\n */\nexport const sort = /*#__PURE__*/dual(2, (self, O) => {\n  const out = Array.from(self);\n  out.sort(O.compare);\n  return out;\n});\n/**\n * Sort the elements of a `NonEmptyReadonlyArray` in increasing order, creating a new `NonEmptyArray`.\n *\n * @category sorting\n * @since 1.0.0\n */\nexport const sortNonEmpty = /*#__PURE__*/dual(2, (self, O) => sort(O)(self));\n/**\n * Sort the elements of an `Iterable` in increasing order, where elements are compared\n * using first `orders[0]`, then `orders[1]`, etc...\n *\n * @category sorting\n * @since 1.0.0\n */\nexport const sortBy = (...orders) => self => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? sortByNonEmpty(...orders)(input) : [];\n};\n/**\n * @category sorting\n * @since 1.0.0\n */\nexport const sortByNonEmpty = (...orders) => sortNonEmpty(order.getMonoid().combineAll(orders));\n/**\n * Takes two `Iterable`s and returns an `Array` of corresponding pairs.\n * If one input `Iterable` is short, excess elements of the\n * longer `Iterable` are discarded.\n *\n * @since 1.0.0\n */\nexport const zip = /*#__PURE__*/dual(2, (self, that) => zipWith(self, that, (a, b) => [a, b]));\n/**\n * Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one\n * input `Iterable` is short, excess elements of the longer `Iterable` are discarded.\n *\n * @since 1.0.0\n */\nexport const zipWith = /*#__PURE__*/dual(3, (self, that, f) => {\n  const as = fromIterable(self);\n  const bs = fromIterable(that);\n  return isNonEmptyReadonlyArray(as) && isNonEmptyReadonlyArray(bs) ? zipNonEmptyWith(bs, f)(as) : [];\n});\n/**\n * @since 1.0.0\n */\nexport const zipNonEmpty = /*#__PURE__*/dual(2, (self, that) => zipNonEmptyWith(self, that, (a, b) => [a, b]));\n/**\n * @since 1.0.0\n */\nexport const zipNonEmptyWith = /*#__PURE__*/dual(3, (self, that, f) => {\n  const cs = [f(headNonEmpty(self), headNonEmpty(that))];\n  const len = Math.min(self.length, that.length);\n  for (let i = 1; i < len; i++) {\n    cs[i] = f(self[i], that[i]);\n  }\n  return cs;\n});\n/**\n * This function is the inverse of `zip`. Takes an `Iterable` of pairs and return two corresponding `Array`s.\n *\n * @since 1.0.0\n */\nexport const unzip = self => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? unzipNonEmpty(input) : [[], []];\n};\n/**\n * @since 1.0.0\n */\nexport const unzipNonEmpty = self => {\n  const fa = [self[0][0]];\n  const fb = [self[0][1]];\n  for (let i = 1; i < self.length; i++) {\n    fa[i] = self[i][0];\n    fb[i] = self[i][1];\n  }\n  return [fa, fb];\n};\n/**\n * Places an element in between members of an `Iterable`\n *\n * @since 1.0.0\n */\nexport const intersperse = /*#__PURE__*/dual(2, (self, middle) => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? intersperseNonEmpty(input, middle) : [];\n});\n/**\n * Places an element in between members of a `NonEmptyReadonlyArray`\n *\n * @since 1.0.0\n */\nexport const intersperseNonEmpty = /*#__PURE__*/dual(2, (self, middle) => {\n  const out = [headNonEmpty(self)];\n  const tail = tailNonEmpty(self);\n  for (let i = 0; i < tail.length; i++) {\n    if (i < tail.length) {\n      out.push(middle);\n    }\n    out.push(tail[i]);\n  }\n  return out;\n});\n/**\n * Apply a function to the head, creating a new `NonEmptyReadonlyArray`.\n *\n * @since 1.0.0\n */\nexport const modifyNonEmptyHead = /*#__PURE__*/dual(2, (self, f) => [f(headNonEmpty(self)), ...tailNonEmpty(self)]);\n/**\n * Change the head, creating a new `NonEmptyReadonlyArray`.\n *\n * @since 1.0.0\n */\nexport const setNonEmptyHead = /*#__PURE__*/dual(2, (self, b) => modifyNonEmptyHead(self, () => b));\n/**\n * Apply a function to the last element, creating a new `NonEmptyReadonlyArray`.\n *\n * @since 1.0.0\n */\nexport const modifyNonEmptyLast = /*#__PURE__*/dual(2, (self, f) => append(initNonEmpty(self), f(lastNonEmpty(self))));\n/**\n * Change the last element, creating a new `NonEmptyReadonlyArray`.\n *\n * @since 1.0.0\n */\nexport const setNonEmptyLast = /*#__PURE__*/dual(2, (self, b) => modifyNonEmptyLast(self, () => b));\n/**\n * Rotate an `Iterable` by `n` steps.\n *\n * @since 1.0.0\n */\nexport const rotate = /*#__PURE__*/dual(2, (self, n) => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? rotateNonEmpty(input, n) : [];\n});\n/**\n * Rotate a `NonEmptyReadonlyArray` by `n` steps.\n *\n * @since 1.0.0\n */\nexport const rotateNonEmpty = /*#__PURE__*/dual(2, (self, n) => {\n  const len = self.length;\n  const m = Math.round(n) % len;\n  if (isOutOfBound(Math.abs(m), self) || m === 0) {\n    return copy(self);\n  }\n  if (m < 0) {\n    const [f, s] = splitNonEmptyAt(self, -m);\n    return appendAllNonEmpty(s, f);\n  } else {\n    return rotateNonEmpty(self, m - len);\n  }\n});\n/**\n * Returns a function that checks if a `ReadonlyArray` contains a given value using a provided `equivalence` function.\n *\n * @category predicates\n * @since 1.0.0\n */\nexport const contains = isEquivalent => dual(2, (self, a) => {\n  for (const i of self) {\n    if (isEquivalent(a, i)) {\n      return true;\n    }\n  }\n  return false;\n});\n/**\n * Remove duplicates from am `Iterable`, keeping the first occurrence of an element.\n *\n * @since 1.0.0\n */\nexport const uniq = /*#__PURE__*/dual(2, (self, isEquivalent) => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? uniqNonEmpty(isEquivalent)(input) : [];\n});\n/**\n * Remove duplicates from a `NonEmptyReadonlyArray`, keeping the first occurrence of an element.\n *\n * @since 1.0.0\n */\nexport const uniqNonEmpty = /*#__PURE__*/dual(2, (self, isEquivalent) => {\n  const out = [headNonEmpty(self)];\n  const rest = tailNonEmpty(self);\n  for (const a of rest) {\n    if (out.every(o => !isEquivalent(a, o))) {\n      out.push(a);\n    }\n  }\n  return out;\n});\n/**\n * A useful recursion pattern for processing an `Iterable` to produce a new `Array`, often used for \"chopping\" up the input\n * `Iterable`. Typically chop is called with some function that will consume an initial prefix of the `Iterable` and produce a\n * value and the rest of the `Array`.\n *\n * @since 1.0.0\n */\nexport const chop = /*#__PURE__*/dual(2, (self, f) => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? chopNonEmpty(input, f) : [];\n});\n/**\n * A useful recursion pattern for processing a `NonEmptyReadonlyArray` to produce a new `NonEmptyReadonlyArray`, often used for \"chopping\" up the input\n * `NonEmptyReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `NonEmptyReadonlyArray` and produce a\n * value and the tail of the `NonEmptyReadonlyArray`.\n *\n * @since 1.0.0\n */\nexport const chopNonEmpty = /*#__PURE__*/dual(2, (self, f) => {\n  const [b, rest] = f(self);\n  const out = [b];\n  let next = rest;\n  while (readonlyArray.isNonEmptyArray(next)) {\n    const [b, rest] = f(next);\n    out.push(b);\n    next = rest;\n  }\n  return out;\n});\n/**\n * Splits an `Iterable` into two pieces, the first piece has max `n` elements.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const splitAt = /*#__PURE__*/dual(2, (self, n) => {\n  const input = Array.from(self);\n  return n >= 1 && isNonEmptyReadonlyArray(input) ? splitNonEmptyAt(input, n) : isEmptyReadonlyArray(input) ? [input, []] : [[], input];\n});\n/**\n * @since 1.0.0\n */\nexport const copy = self => self.slice();\n/**\n * Splits a `NonEmptyReadonlyArray` into two pieces, the first piece has max `n` elements.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const splitNonEmptyAt = /*#__PURE__*/dual(2, (self, n) => {\n  const m = Math.max(1, n);\n  return m >= self.length ? [copy(self), []] : [prepend(self.slice(1, m), headNonEmpty(self)), self.slice(m)];\n});\n/**\n * Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `Iterable`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `self`.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const chunksOf = /*#__PURE__*/dual(2, (self, n) => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? chunksOfNonEmpty(input, n) : [];\n});\n/**\n * Splits a `NonEmptyReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `NonEmptyReadonlyArray`.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const chunksOfNonEmpty = /*#__PURE__*/dual(2, (self, n) => chopNonEmpty(self, splitNonEmptyAt(n)));\n/**\n * Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s.\n *\n * @category grouping\n * @since 1.0.0\n */\nexport const group = /*#__PURE__*/dual(2, (self, isEquivalent) => chopNonEmpty(self, as => {\n  const h = headNonEmpty(as);\n  const out = [h];\n  let i = 1;\n  for (; i < as.length; i++) {\n    const a = as[i];\n    if (isEquivalent(a, h)) {\n      out.push(a);\n    } else {\n      break;\n    }\n  }\n  return [out, as.slice(i)];\n}));\n/**\n * Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @category grouping\n * @since 1.0.0\n */\nexport const groupBy = /*#__PURE__*/dual(2, (self, f) => {\n  const out = {};\n  for (const a of self) {\n    const k = f(a);\n    if (Object.prototype.hasOwnProperty.call(out, k)) {\n      out[k].push(a);\n    } else {\n      out[k] = [a];\n    }\n  }\n  return out;\n});\n/**\n * @since 1.0.0\n */\nexport const union = isEquivalent => dual(2, (self, that) => {\n  const a = Array.from(self);\n  const b = Array.from(that);\n  return isNonEmptyReadonlyArray(a) && isNonEmptyReadonlyArray(b) ? unionNonEmpty(isEquivalent)(a, b) : isNonEmptyReadonlyArray(a) ? a : b;\n});\n/**\n * @since 1.0.0\n */\nexport const unionNonEmpty = isEquivalent => dual(2, (self, that) => uniqNonEmpty(isEquivalent)(appendAllNonEmpty(self, that)));\n/**\n * Creates an `Array` of unique values that are included in all given `Iterable`s.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * @since 1.0.0\n */\nexport const intersection = isEquivalent => {\n  const has = contains(isEquivalent);\n  return dual(2, (self, that) => fromIterable(self).filter(a => has(that, a)));\n};\n/**\n * Creates a `Array` of values not included in the other given `Iterable`.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * @since 1.0.0\n */\nexport const difference = isEquivalent => {\n  const has = contains(isEquivalent);\n  return dual(2, (self, that) => fromIterable(self).filter(a => !has(that, a)));\n};\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const empty = () => [];\n/**\n * Constructs a new `NonEmptyArray<A>` from the specified value.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const of = a => [a];\nconst Of = {\n  of\n};\n/**\n * @category mapping\n * @since 1.0.0\n */\nexport const map = /*#__PURE__*/dual(2, (self, f) => self.map(f));\n/**\n * @category mapping\n * @since 1.0.0\n */\nexport const mapNonEmpty = map;\nconst imap = /*#__PURE__*/covariant.imap(map);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Covariant = {\n  imap,\n  map\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Invariant = {\n  imap\n};\n/**\n * @category mapping\n * @since 1.0.0\n */\nexport const tupled = /*#__PURE__*/invariant.tupled(Invariant);\n/**\n * @category mapping\n * @since 1.0.0\n */\nexport const tuple = (...args) => args;\n/**\n * @category mapping\n * @since 1.0.0\n */\nexport const flap = /*#__PURE__*/covariant.flap(Covariant);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Pointed = {\n  of,\n  imap,\n  map\n};\n/**\n * @category combining\n * @since 1.0.0\n */\nexport const flatMap = /*#__PURE__*/dual(2, (self, f) => {\n  if (isEmptyReadonlyArray(self)) {\n    return [];\n  }\n  const out = [];\n  for (let i = 0; i < self.length; i++) {\n    out.push(...f(self[i], i));\n  }\n  return out;\n});\n/**\n * @category combining\n * @since 1.0.0\n */\nexport const flatMapNonEmpty = flatMap;\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const FlatMap = {\n  flatMap\n};\n/**\n * @category combining\n * @since 1.0.0\n */\nexport const flatten = /*#__PURE__*/flatMap_.flatten(FlatMap);\n/**\n * @category combining\n * @since 1.0.0\n */\nexport const flattenNonEmpty = /*#__PURE__*/flatMapNonEmpty(identity);\n/**\n * @since 1.0.0\n */\nexport const composeK = /*#__PURE__*/flatMap_.composeK(FlatMap);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Chainable = {\n  imap,\n  map,\n  flatMap\n};\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const filterMap = /*#__PURE__*/dual(2, (self, f) => {\n  const as = fromIterable(self);\n  const out = [];\n  for (let i = 0; i < as.length; i++) {\n    const o = f(as[i], i);\n    if (O.isSome(o)) {\n      out.push(o.value);\n    }\n  }\n  return out;\n});\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const partitionMap = /*#__PURE__*/dual(2, (self, f) => {\n  const left = [];\n  const right = [];\n  const as = fromIterable(self);\n  for (let i = 0; i < as.length; i++) {\n    const e = f(as[i], i);\n    if (E.isLeft(e)) {\n      left.push(e.left);\n    } else {\n      right.push(e.right);\n    }\n  }\n  return [left, right];\n});\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Filterable = {\n  partitionMap,\n  filterMap\n};\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const compact = /*#__PURE__*/filterMap(identity);\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const filter = /*#__PURE__*/dual(2, (self, predicate) => {\n  const as = fromIterable(self);\n  const out = [];\n  for (let i = 0; i < as.length; i++) {\n    if (predicate(as[i], i)) {\n      out.push(as[i]);\n    }\n  }\n  return out;\n});\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const partition = /*#__PURE__*/dual(2, (self, predicate) => {\n  const left = [];\n  const right = [];\n  const as = fromIterable(self);\n  for (let i = 0; i < as.length; i++) {\n    if (predicate(as[i], i)) {\n      right.push(as[i]);\n    } else {\n      left.push(as[i]);\n    }\n  }\n  return [left, right];\n});\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const separate = /*#__PURE__*/partitionMap(identity);\n/**\n * @category traversing\n * @since 1.0.0\n */\nexport const traverseNonEmpty = F => dual(2, (self, f) => {\n  const [head, ...tail] = mapNonEmpty(self, f);\n  return F.productMany(head, tail);\n});\n/**\n * @category traversing\n * @since 1.0.0\n */\nexport const traverse = F => dual(2, (self, f) => F.productAll(fromIterable(self).map(f)));\n/**\n * @category traversing\n * @since 1.0.0\n */\nexport const sequence = F => traverse(F)(identity);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Traversable = {\n  traverse: traverse\n};\n/**\n * @category traversing\n * @since 1.0.0\n */\nexport const traverseTap = /*#__PURE__*/traversable.traverseTap(Traversable);\n/**\n * @category traversing\n * @since 1.0.0\n */\nexport const sequenceNonEmpty = F => traverseNonEmpty(F)(identity);\nconst product = (self, that) => {\n  if (isEmptyReadonlyArray(self) || isEmptyReadonlyArray(that)) {\n    return empty();\n  }\n  const out = [];\n  for (let i = 0; i < self.length; i++) {\n    for (let j = 0; j < that.length; j++) {\n      out.push([self[i], that[j]]);\n    }\n  }\n  return out;\n};\nconst productMany = /*#__PURE__*/semiProduct.productMany(map, product);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const SemiProduct = {\n  imap,\n  product,\n  productMany\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const SemiApplicative = {\n  imap,\n  map,\n  product,\n  productMany\n};\n/**\n * @since 1.0.0\n */\nexport const ap = /*#__PURE__*/semiApplicative.ap(SemiApplicative);\n/**\n * Lifts a binary function into `ReadonlyArray`.\n *\n * @param f - The function to lift.\n *\n * @category lifting\n * @since 1.0.0\n */\nexport const lift2 = /*#__PURE__*/semiApplicative.lift2(SemiApplicative);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Product = {\n  of,\n  imap,\n  product,\n  productMany,\n  productAll: collection => {\n    const arrays = fromIterable(collection);\n    return isEmptyReadonlyArray(arrays) ? empty() : SemiProduct.productMany(arrays[0], arrays.slice(1));\n  }\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Applicative = {\n  imap,\n  of,\n  map,\n  product,\n  productMany,\n  productAll: Product.productAll\n};\n/**\n * @category lifting\n * @since 1.0.0\n */\nexport const liftMonoid = /*#__PURE__*/applicative.getMonoid(Applicative);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Monad = {\n  imap,\n  of,\n  map,\n  flatMap\n};\n/**\n * @category folding\n * @since 1.0.0\n */\nexport const reduce = /*#__PURE__*/dual(3, (self, b, f) => fromIterable(self).reduce((b, a, i) => f(b, a, i), b));\n/**\n * @category folding\n * @since 1.0.0\n */\nexport const reduceRight = /*#__PURE__*/dual(3, (self, b, f) => fromIterable(self).reduceRight((b, a, i) => f(b, a, i), b));\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Foldable = {\n  reduce\n};\n/**\n * @category folding\n * @since 1.0.0\n */\nexport const combineMap = Monoid => dual(2, (self, f) => fromIterable(self).reduce((m, a, i) => Monoid.combine(m, f(a, i)), Monoid.empty));\n/**\n * @category folding\n * @since 1.0.0\n */\nexport const combineMapNonEmpty = S => dual(2, (self, f) => tailNonEmpty(self).reduce((s, a, i) => S.combine(s, f(a, i + 1)), f(headNonEmpty(self), 0)));\n/**\n * @category folding\n * @since 1.0.0\n */\nexport const reduceKind = /*#__PURE__*/foldable.reduceKind(Foldable);\n/**\n * @category folding\n * @since 1.0.0\n */\nexport const coproductMapKind = /*#__PURE__*/foldable.coproductMapKind(Foldable);\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const traversePartitionMap = F => dual(2, (self, f) => {\n  return F.map(traverse(F)(self, f), separate);\n});\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const traverseFilterMap = F => dual(2, (self, f) => {\n  return F.map(traverse(F)(self, f), compact);\n});\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const TraversableFilterable = {\n  traversePartitionMap: traversePartitionMap,\n  traverseFilterMap: traverseFilterMap\n};\n/**\n * Filter values inside a context.\n *\n * @since 1.0.0\n */\nexport const traverseFilter = /*#__PURE__*/traversableFilterable.traverseFilter(TraversableFilterable);\n/**\n * @since 1.0.0\n */\nexport const traversePartition = /*#__PURE__*/traversableFilterable.traversePartition(TraversableFilterable);\n/**\n * @category lifting\n * @since 1.0.0\n */\nexport const liftPredicate = predicate => b => predicate(b) ? [b] : [];\n/**\n * @category lifting\n * @since 1.0.0\n */\nexport const liftOption = f => (...a) => fromOption(f(...a));\n/**\n * @category conversions\n * @since 1.0.0\n */\nexport const fromNullable = a => a == null ? empty() : [a];\n/**\n * @category lifting\n * @since 1.0.0\n */\nexport const liftNullable = f => (...a) => fromNullable(f(...a));\n/**\n * @category combining\n * @since 1.0.0\n */\nexport const flatMapNullable = /*#__PURE__*/dual(2, (self, f) => isNonEmptyReadonlyArray(self) ? fromNullable(f(headNonEmpty(self))) : empty());\n/**\n * @category lifting\n * @since 1.0.0\n */\nexport const liftEither = f => (...a) => {\n  const e = f(...a);\n  return E.isLeft(e) ? [] : [e.right];\n};\nexport function every(predicate) {\n  return self => self.every(predicate);\n}\n/**\n * Check if a predicate holds true for some `ReadonlyArray` member.\n *\n * @category predicates\n * @since 1.0.0\n */\nexport const some = predicate => self => self.some(predicate);\n/**\n * Fold an `Iterable`, accumulating values in some `Monoid`, combining adjacent elements\n * using the specified separator.\n *\n * @since 1.0.0\n */\nexport const intercalate = M => dual(2, (self, middle) => {\n  const as = fromIterable(self);\n  return isNonEmptyReadonlyArray(as) ? intercalateNonEmpty(M)(as, middle) : M.empty;\n});\n/**\n * Places an element in between members of a `NonEmptyReadonlyArray`, then folds the results using the provided `Semigroup`.\n *\n * @since 1.0.0\n */\nexport const intercalateNonEmpty = S => dual(2, (self, middle) => semigroup.intercalate(S, middle).combineMany(headNonEmpty(self), tailNonEmpty(self)));\n/**\n * @since 1.0.0\n */\nexport const join = /*#__PURE__*/intercalate(string.Monoid);\n/**\n * @since 1.0.0\n */\nexport const extend = /*#__PURE__*/dual(2, (self, f) => self.map((_, i, as) => f(as.slice(i))));\n/**\n * @since 1.0.0\n */\nexport const min = /*#__PURE__*/dual(2, (self, O) => {\n  const S = semigroup.min(O);\n  return self.reduce(S.combine);\n});\n/**\n * @since 1.0.0\n */\nexport const max = /*#__PURE__*/dual(2, (self, O) => {\n  const S = semigroup.max(O);\n  return self.reduce(S.combine);\n});\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const unfold = (b, f) => {\n  const out = [];\n  let next = b;\n  let o;\n  while (O.isSome(o = f(next))) {\n    const [a, b] = o.value;\n    out.push(a);\n    next = b;\n  }\n  return out;\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const getUnionSemigroup = isEquivalent => semigroup.make(union(isEquivalent));\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const getUnionMonoid = isEquivalent => {\n  const S = getUnionSemigroup(isEquivalent);\n  return {\n    combine: S.combine,\n    combineMany: S.combineMany,\n    combineAll: collection => S.combineMany([], collection),\n    empty: []\n  };\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const getIntersectionSemigroup = isEquivalent => semigroup.make(intersection(isEquivalent));\n/**\n * Returns a `Semigroup` for `ReadonlyArray<A>`.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const getSemigroup = semigroup.array;\n/**\n * Returns a `Monoid` for `ReadonlyArray<A>`.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const getMonoid = monoid.array;\n/**\n * This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.\n * The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.\n * If all elements are equal, the arrays are then compared based on their length.\n * It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const getOrder = order.array;\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const getEquivalence = equivalence.array;\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 1.0.0\n */\nexport const bindTo = /*#__PURE__*/invariant.bindTo(Invariant);\nconst let_ = /*#__PURE__*/covariant.let(Covariant);\nexport {\n/**\n * @category do notation\n * @since 1.0.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 1.0.0\n */\nexport const letDiscard = /*#__PURE__*/covariant.letDiscard(Covariant);\n/**\n * @category do notation\n * @since 1.0.0\n */\nexport const Do = /*#__PURE__*/of_.Do(Of);\n/**\n * @category do notation\n * @since 1.0.0\n */\nexport const bind = /*#__PURE__*/chainable.bind(Chainable);\n/**\n * A variant of `bind` that sequentially ignores the scope.\n *\n * @category do notation\n * @since 1.0.0\n */\nexport const bindDiscard = /*#__PURE__*/semiProduct.bindDiscard(SemiProduct);\n//# sourceMappingURL=ReadonlyArray.mjs.map","/**\n * @since 1.0.0\n */\n/** @internal */\nexport const isNonEmptyArray = self => self.length > 0;\n/** @internal */\nexport const fromIterable = collection => Array.isArray(collection) ? collection : Array.from(collection);\n//# sourceMappingURL=ReadonlyArray.mjs.map","import { pipe, } from '@effect/data/Function';\nimport * as O from '@effect/data/Option';\nimport * as RA from '@effect/data/ReadonlyArray';\nimport { h, text, } from 'hyperapp';\nexport default (style) => (ontabSelect) => (labels) => (tabs) => (mainTab) => h('div', {\n    style: style.container,\n}, [\n    h('div', {}, pipe(labels, RA.map((x, i) => h('span', {\n        style: {\n            ...style.label,\n            ...(mainTab === i ? style.labelFocus : {}),\n            display: 'inline-block',\n        },\n        onpointerdown: [ontabSelect, i],\n    }, text(x))))),\n    h('div', {\n        style: {\n            ...style.tab,\n            overflow: 'auto',\n            boxSizing: 'border-box',\n        },\n    }, pipe(tabs, RA.get(mainTab), O.match(() => undefined, (x) => x()))),\n]);\n","import { constant, pipe, } from '@effect/data/Function';\nimport * as O from '@effect/data/Option';\nimport * as RA from '@effect/data/ReadonlyArray';\nimport { h, } from 'hyperapp';\nimport * as Ed from '@/Editable';\nexport default (rows, action) => (value) => h('textarea', {\n    rows,\n    style: {\n        resize: 'none',\n        boxSizing: 'border-box',\n        width: '100%',\n        borderColor: Ed.hasError(value) ? '#f55' : undefined,\n    },\n    value: pipe(value, Ed.text, O.getOrElse(pipe(Ed.value(value), RA.join('\\n'), constant))),\n    ...action,\n});\n","import { constant, pipe, } from '@effect/data/Function';\nimport * as O from '@effect/data/Option';\nimport { h, } from 'hyperapp';\nimport * as Ed from '@/Editable';\nexport default (action) => (value) => h('input', {\n    style: {\n        verticalAlign: 'middle',\n        width: '5.5em',\n        borderColor: Ed.hasError(value) ? '#f55' : undefined,\n    },\n    maxlength: 20,\n    value: pipe(value, Ed.text, O.getOrElse(constant(Ed.value(value)))),\n    ...action,\n});\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","EMPTY_OBJ","EMPTY_ARR","isArray","Array","createClass","requestAnimationFrame","setTimeout","out","tmp","k","length","createVNode","tag","props","children","type","node","h","class","c","label","checked","onchange","action","color","style","width","verticalAlign","oninput","textStyle","arity","body","isDataFirst","args","arguments","apply","this","a","ab","bc","cd","de","ef","fg","gh","hi","ij","pipe","ret","i","globalStoreId","for","globalThis","Map","globalStore","globalValue","id","compute","has","set","isNothing","PCGRandom","constructor","seedHi","seedLo","incHi","incLo","Math","random","_state","Int32Array","_next","add64","getState","setState","state","integer","max","num","skew","number","oldHi","oldLo","aHi","aLo","bHi","bLo","c1","c0","lo","imul","mul64","xsHi","xsLo","xorshifted","rot","randomHashCache","WeakMap","pcgr","symbol","hash","string","toString","String","isHash","Error","Number","MAX_SAFE_INTEGER","optimize","n","u","Infinity","str","charCodeAt","equals","compareBoth","that","selfType","isEqual","_a","EffectTypeId","TracedPrimitive","i0","trace","_tag","i1","undefined","i2","effectVariance","traced","_R","_","_E","_A","makeTraced","source","_b","OptionTypeId","Some","isOption","isSome","toJSON","None","isNone","input","fa","none","Right","isEither","isRight","right","EitherTypeId","Left","isLeft","left","compare","make","combine","combineMany","collection","reduce","b","f","iterable","result","numberSum","numberMultiply","intercalate","S","separator","fromSemigroup","empty","combineAll","MonoidMultiply","match","onNone","onSome","getOrElse","flatMap","getFirst","getSecond","mapFirst","F","bimap","g","error","hasError","x","subject","edit","util","objectUtil","assertEqual","val","assertIs","_arg","assertNever","_x","arrayToEnum","items","item","getValidEnumValues","validKeys","objectKeys","filter","filtered","objectValues","map","e","keys","object","push","find","arr","checker","isInteger","isFinite","floor","joinValues","array","join","jsonStringifyReplacer","mergeShapes","first","second","ZodParsedType","getParsedType","data","isNaN","nan","boolean","function","bigint","null","then","catch","promise","Set","Date","date","unknown","ZodIssueCode","ZodError","issues","super","addIssue","sub","addIssues","subs","actualProto","setPrototypeOf","__proto__","name","errors","format","_mapper","mapper","issue","message","fieldErrors","_errors","processError","code","unionErrors","returnTypeError","argumentsError","path","curr","el","JSON","stringify","isEmpty","flatten","formErrors","create","errorMap","_ctx","invalid_type","received","expected","invalid_literal","unrecognized_keys","invalid_union","invalid_union_discriminator","options","invalid_enum_value","invalid_arguments","invalid_return_type","invalid_date","invalid_string","validation","includes","position","startsWith","endsWith","too_small","exact","inclusive","minimum","too_big","maximum","custom","invalid_intersection_types","not_multiple_of","multipleOf","not_finite","defaultError","overrideErrorMap","getErrorMap","makeIssue","params","errorMaps","issueData","fullPath","fullIssue","errorMessage","maps","m","slice","reverse","addIssueToContext","ctx","common","contextualErrorMap","schemaErrorMap","ParseStatus","dirty","abort","static","status","results","arrayValue","s","INVALID","pairs","syncPairs","pair","mergeObjectSync","finalObject","alwaysSet","freeze","DIRTY","OK","isAborted","isDirty","isValid","isAsync","Promise","errorUtil","errToObj","ParseInputLazyPath","parent","_cachedPath","_path","_key","handleResult","success","_error","processCreateParams","invalid_type_error","required_error","description","iss","ZodType","def","spa","safeParseAsync","_def","parse","bind","safeParse","parseAsync","refine","refinement","superRefine","optional","nullable","nullish","or","and","transform","brand","default","describe","isNullable","isOptional","_getType","_getOrReturnCtx","parsedType","_processInputParams","_parseSync","_parse","_parseAsync","resolve","async","maybeAsyncResult","check","getIssueProperties","_refinement","setError","refinementData","ZodEffects","schema","typeName","ZodFirstPartyTypeKind","effect","ZodOptional","ZodNullable","ZodArray","ZodPromise","option","ZodUnion","incoming","ZodIntersection","defaultValueFunc","ZodDefault","innerType","defaultValue","ZodBranded","catchValueFunc","ZodCatch","catchValue","This","target","ZodPipeline","cuidRegex","cuid2Regex","ulidRegex","uuidRegex","emailRegex","emojiRegex","ipv4Regex","ipv6Regex","ZodString","_regex","regex","test","nonempty","min","trim","checks","kind","toLowerCase","toUpperCase","coerce","tooBig","tooSmall","URL","lastIndex","precision","offset","RegExp","ip","version","_addCheck","email","url","emoji","uuid","cuid","cuid2","ulid","datetime","minLength","maxLength","len","isDatetime","ch","isEmail","isURL","isEmoji","isUUID","isCUID","isCUID2","isULID","isIP","floatSafeRemainder","step","valDecCount","split","stepDecCount","decCount","parseInt","toFixed","replace","pow","ZodNumber","gte","lte","setLimit","gt","lt","int","positive","negative","nonpositive","nonnegative","finite","safe","MIN_SAFE_INTEGER","minValue","maxValue","isInt","ZodBigInt","BigInt","ZodBoolean","Boolean","ZodDate","getTime","minDate","maxDate","ZodSymbol","ZodUndefined","ZodNull","ZodAny","_any","ZodUnknown","_unknown","ZodNever","never","ZodVoid","void","exactLength","all","mergeArray","element","deepPartialify","ZodObject","newShape","shape","fieldSchema","unwrap","ZodTuple","_cached","nonstrict","passthrough","augment","extend","_getCached","shapeKeys","extraKeys","catchall","unknownKeys","keyValidator","strict","_c","_d","strip","augmentation","merge","merging","setKey","index","pick","mask","forEach","omit","deepPartial","partial","required","newField","keyof","createZodEnum","strictCreate","lazycreate","childCtx","types","getDiscriminator","ZodLazy","ZodLiteral","ZodEnum","ZodNativeEnum","enum","ZodDiscriminatedUnion","discriminator","discriminatorValue","optionsMap","from","discriminatorValues","mergeValues","aType","bType","valid","bKeys","sharedKeys","indexOf","newObj","sharedValue","newArray","handleParsed","parsedLeft","parsedRight","merged","rest","itemIndex","schemas","ZodRecord","keySchema","keyType","valueSchema","valueType","mergeObjectAsync","third","ZodMap","entries","finalMap","ZodSet","minSize","size","maxSize","finalizeSet","elements","parsedSet","add","values","ZodFunction","validate","implement","makeArgsIssue","makeReturnsIssue","returns","fn","parsedArgs","parsedReturns","parameters","returnType","func","strictImplement","getter","expectedValues","enumValues","Values","Enum","extract","exclude","opt","nativeEnumValues","promisified","sourceType","processed","checkCtx","arg","fatal","executeRefinement","acc","inner","base","createWithPreprocess","preprocess","removeDefault","newCtx","removeCatch","ZodNaN","BRAND","inResult","in","handleAsync","p","_fatal","p2","late","stringType","numberType","nanType","bigIntType","booleanType","dateType","symbolType","undefinedType","nullType","anyType","unknownType","neverType","voidType","arrayType","objectType","strictObjectType","unionType","discriminatedUnionType","intersectionType","tupleType","recordType","mapType","setType","functionType","lazyType","literalType","enumType","nativeEnumType","promiseType","effectsType","optionalType","nullableType","preprocessType","pipelineType","NEVER","z","defaultErrorMap","setErrorMap","EMPTY_PATH","ZodTransformer","Schema","ZodSchema","any","discriminatedUnion","cls","intersection","lazy","literal","nativeEnum","oboolean","onumber","ostring","pipeline","record","strictObject","transformer","tuple","union","quotelessJson","HTMLInputElement","currentTarget","HTMLSelectElement","HTMLTextAreaElement","selected","flex","margin","backgroundColor","borderWidth","borderColor","inputmode","content","marginLeft","whiteSpace","Monoid","LinesIterator","stripped","next","done","start","isLineBreak","end","char","isLineBreak2","substring","iterator","char0","char1","isNonEmptyReadonlyArray","isOutOfBound","as","headNonEmpty","unsafeGet","M","middle","intercalateNonEmpty","tailNonEmpty","ontabSelect","labels","tabs","mainTab","container","labelFocus","display","onpointerdown","tab","overflow","boxSizing","rows","resize","maxlength"],"sourceRoot":""}